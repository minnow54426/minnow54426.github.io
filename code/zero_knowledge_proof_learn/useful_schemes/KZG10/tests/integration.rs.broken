//! Integration tests for KZG10
//!
//! This test module validates the KZG10 implementation under **production-scale scenarios**
//! and **stress conditions** that go beyond unit tests and property-based tests.
//!
//! # What Are Integration Tests?
//!
//! While unit tests verify individual functions (e.g., "does commit() work for degree 3?") and
//! property-based tests verify mathematical properties across random inputs, integration tests
//! validate **real-world production scenarios**:
//!
//! - **Large-scale operations**: Can we commit to degree 2²⁰ polynomials efficiently?
//! - **Batch processing**: Do batch operations work correctly at scale?
//! - **Failure modes**: Does the system correctly detect and reject invalid proofs?
//! - **Serialization**: Can we save/load commitments and proofs correctly?
//! - **Memory usage**: Do large operations cause memory issues?
//! - **Concurrency**: Are operations thread-safe (if applicable)?
//!
//! # Why Integration Tests Matter for Production
//!
//! A cryptographic library may pass all unit tests but still fail in production due to:
//!
//! 1. **Performance degradation at scale**: MSM may be fast for degree 1000 but slow for 2²⁰
//! 2. **Memory issues**: Large polynomials may cause stack overflow or OOM
//! 3. **Edge cases**: Corner cases not covered by unit tests (e.g., zero polynomial, max degree)
//! 4. **Serialization bugs**: Binary format issues only appear when saving/loading
//! 5. **Batch verification failures**: Random linear combination may have numerical issues
//!
//! Integration tests catch these problems BEFORE they reach production.
//!
//! # Test Categories
//!
//! ## 1. Large Polynomial Commitments (Stress Tests)
//!
//! Tests commit, open, and verify for polynomials of increasing degrees:
//! - Degree 2⁸ (256): Small-scale (should be instant)
//! - Degree 2¹² (4096): Medium-scale (~10ms for commit)
//! - Degree 2¹⁶ (65536): Large-scale (~80ms for commit)
//! - Degree 2²⁰ (1M): Very large-scale (~500ms for commit)
//!
//! **Real-world relevance**:
//! - Blockchain rollups: Degree 2¹⁶ is common for transaction batches
//! - Verkle trees: Degree 2²⁰ needed for large state trees
//! - zk-SNARK circuits: Degree 2¹² to 2²⁰ depending on circuit complexity
//!
//! **Performance expectations**:
//! - Commit time: O(n / log n) with Pippenger's algorithm
//! - Open time: O(n) for evaluation and division
//! - Verify time: O(1) - constant time, independent of degree!
//!
//! ## 2. Multi-Point Openings
//!
//! Test opening the same polynomial at multiple points:
//! - 2 points: Basic multi-opening
//! - 4 points: Moderate multi-opening
//! - 8 points: Larger multi-opening
//! - 16 points: Stress test for multi-opening
//!
//! **Real-world relevance**:
//! - **Verkle trees**: Need proofs for multiple keys in a trie
//! - **Stateless clients**: Validate multiple state entries simultaneously
//! - **Batch queries**: Reduce verification overhead for multiple reads
//!
//! **Performance expectations**:
//! - Each opening: O(n) individually, O(n) total with optimizations
//! - Verification: O(1) per opening with batching
//!
//! ## 3. Failure Modes (Security Tests)
//!
//! Test that the implementation correctly rejects invalid proofs:
//! - **Wrong value**: P(z) = 5, claim P(z) = 6
//! - **Tampered commitment**: Modify commitment bytes
//! - **Tampered proof**: Modify proof witness bytes
//! - **Wrong point**: Claim proof for z₁ is valid for z₂
//!
//! **Real-world relevance**:
//! - **Network adversaries**: Malicious nodes may send fake proofs
//! - **Storage corruption**: Disk errors may corrupt stored commitments
//! - **Software bugs**: Bugs may produce invalid proofs
//!
//! **Security expectations**:
//! - False acceptance rate: ≤ 1/|Fr| ≈ 2^(-254) for BLS12-381
//! - All tampered proofs should be rejected
//! - No edge cases bypass verification
//!
//! ## 4. Serialization/Deserialization
//!
//! Test saving and loading commitments, proofs, and SRS:
//! - Commitment serialization (48 bytes G1 point)
//! - Proof serialization (48 bytes G1 point)
//! - SRS serialization (large: ~3MB for degree 2¹⁶)
//! - Round-trip tests (serialize → deserialize → verify)
//!
//! **Real-world relevance**:
//! - **Persistent storage**: Save commitments to disk/database
//! - **Network transmission**: Send proofs over P2P network
//! - **State snapshots**: Save/load blockchain state with commitments
//!
//! **Correctness expectations**:
//! - Serialization is deterministic (same input → same bytes)
//! - Deserialization validates point encoding
//! - Round-trip preserves all data (no loss of precision)
//!
//! ## 5. Edge Cases and Boundary Conditions
//!
//! Test unusual but valid scenarios:
//! - **Zero polynomial**: P(x) = 0 (commits to identity element)
//! - **Constant polynomial**: P(x) = c (degree 0)
//! - **Maximum degree**: Polynomial with degree = SRS.max_degree
//! - **Single coefficient**: Polynomial with one non-zero coefficient
//! - **Special field elements**: 0, 1, -1, field characteristic - 1
//!
//! **Real-world relevance**:
//! - **Empty blocks**: Blockchain blocks with no transactions (zero polynomial)
//! - **Initialization**: Initial state trees with constant values
//! - **Boundary testing**: Ensure no off-by-one errors in degree checks
//!
//! ## 6. Memory and Performance Profiling
//!
//! Measure resource usage for large operations:
//! - Memory allocation for degree 2²⁰ polynomial commitment
//! - Time for commit, open, verify at different scales
//! - Memory usage for SRS of different sizes
//!
//! **Real-world relevance**:
//! - **Resource planning**: Can our servers handle degree 2²⁰ commitments?
//! - **Cost optimization**: Should we use multiple smaller commitments?
//! - **SLA guarantees**: Can we verify proofs within time budget?
//!
//! # Performance Benchmarks
//!
//! Based on Pippenger's MSM and modern hardware (AMD Ryzen 9 5900X):
//!
//! | Operation | Degree 2⁸ | Degree 2¹² | Degree 2¹⁶ | Degree 2²⁰ |
//! |-----------|-----------|------------|------------|------------|
//! | Commit | <1ms | ~10ms | ~80ms | ~500ms |
//! | Open | <1ms | ~5ms | ~40ms | ~300ms |
//! | Verify | <1ms | <1ms | <1ms | <1ms |
//! | Memory | ~100KB | ~1MB | ~10MB | ~100MB |
//!
//! # Running the Tests
//!
//! ```bash
//! # Run all integration tests
//! cargo test --test integration --features test-only
//!
//! # Run specific test
//! cargo test --test integration test_large_polynomial_degree_2_12 --features test-only
//!
//! # Run with output (for timing information)
//! cargo test --test integration -- --nocapture --features test-only
//!
//! # Run with memory profiling (requires heaptrack or similar)
//! heaptrack cargo test --test integration --features test-only
//! ```
//!
//! # Notes on Test-Only Feature
//!
//! These tests use the `test-only` feature which enables `setup_for_testing()`.
//! This function is **INSECURE** and **MUST NEVER** be used in production.
//!
//! In production, you would:
//! 1. Load SRS from a trusted powers-of-tau ceremony
//! 2. Verify the ceremony transcript
//! 3. Never know the secret `s`

use ark_bls12_381::{Bls12_381, Fr};
use ark_ec::pairing::Pairing;
use ark_ec::CurveGroup;
use ark_poly::Polynomial;
use ark_poly::DenseUVPolynomial;
use ark_poly::polynomial::univariate::DensePolynomial;
use ark_std::UniformRand;
use ark_std::test_rng;

use kzg10::{batch_verify, Commitment, Opening, SRS};

// ============================================================================
// Section 1: Large Polynomial Commitments (Stress Tests)
// ============================================================================

/// Test commitment, opening, and verification for a degree 2⁸ polynomial
///
/// # Mathematical Context
///
/// Degree 2⁸ = 256 is a relatively small polynomial by cryptographic standards.
/// This test validates the basic correctness of the KZG10 operations for
/// non-trivial polynomial sizes.
///
/// # Real-World Relevance
///
/// - **Small Verkle trees**: Verkle trees with limited depth use degree ~256
/// - **Testing**: Useful for quick smoke tests in CI/CD pipelines
/// - **Development**: Fast iteration during development
///
/// # Performance Expectations
///
/// - Commit time: < 1ms
/// - Open time: < 1ms
/// - Verify time: < 1ms (constant!)
/// - Memory usage: < 100KB
///
/// # What This Test Validates
///
/// 1. MSM works correctly for 256 coefficients
/// 2. Polynomial evaluation and division work for degree 256
/// 3. Pairing verification succeeds for degree 256
/// 4. No memory issues or stack overflows
#[test]
#[cfg(feature = "test-only")]
fn test_large_polynomial_degree_2_8() {
    let max_degree = 256; // 2^8
    let mut rng = test_rng();

    // Setup SRS with random secret (INSECURE! Testing only!)
    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Generate random polynomial of degree 256
    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    // Commit to the polynomial
    let commitment = Commitment::commit(&poly, &srs);

    // Choose random evaluation point
    let point = Fr::rand(&mut rng);
    let expected_value = poly.evaluate(&point);

    // Open at the point
    let opening = Commitment::open(&poly, point, &srs);

    // Verify the opening
    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for degree 2^8 polynomial"
    );

    // Verify the value is correct
    assert_eq!(
        opening.value, expected_value,
        "Opening value mismatch for degree 2^8 polynomial"
    );
}

/// Test commitment, opening, and verification for a degree 2¹² polynomial
///
/// # Mathematical Context
///
/// Degree 2¹² = 4096 is a moderate-sized polynomial. This is the lower bound
/// for production use in many blockchain applications.
///
/// # Real-World Relevance
///
/// - **Blockchain rollups**: Typical batch size for transaction rollups
/// - **zk-SNARK circuits**: Small to medium circuits (e.g., payment channels)
/// - **Verkle trees**: Medium-sized trie branches
/// - **Data availability**: Sample commitment for small data chunks
///
/// # Performance Expectations
///
/// - Commit time: ~10ms (using Pippenger's algorithm)
/// - Open time: ~5ms
/// - Verify time: < 1ms (constant!)
/// - Memory usage: ~1MB
///
/// # What This Test Validates
///
/// 1. MSM scales efficiently to 4096 coefficients (not O(n²))
/// 2. Pippenger's algorithm is being used (not naive MSM)
/// 3. Polynomial operations don't have performance cliffs
/// 4. Memory allocation is efficient (no excessive copying)
#[test]
#[cfg(feature = "test-only")]
fn test_large_polynomial_degree_2_12() {
    let max_degree = 4096; // 2^12
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let expected_value = poly.evaluate(&point);

    let opening = Commitment::open(&poly, point, &srs);

    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for degree 2^12 polynomial"
    );

    assert_eq!(
        opening.value, expected_value,
        "Opening value mismatch for degree 2^12 polynomial"
    );
}

/// Test commitment, opening, and verification for a degree 2¹⁶ polynomial
///
/// # Mathematical Context
///
/// Degree 2¹⁶ = 65536 is a large polynomial. This stress test validates that
/// the implementation can handle production-scale workloads.
///
/// # Real-World Relevance
///
/// - **Ethereum rollups**: Full block batches in Optimism/Arbitrum
/// - **Large zk-SNARK circuits**: Complex smart contract execution
/// - **Verkle trees**: Large state tree branches
/// - **Data availability**: 1MB data chunk commitments
///
/// # Performance Expectations
///
/// - Commit time: ~80ms (using optimized MSM)
/// - Open time: ~40ms
/// - Verify time: < 1ms (constant!)
/// - Memory usage: ~10MB for SRS + polynomial
///
/// # What This Test Validates
///
/// 1. MSM performance is acceptable for production use
/// 2. No performance degradation due to memory allocation
/// 3. Large polynomial evaluation is efficient
/// 4. Verification remains constant-time (critical for scalability)
///
/// # Why This Matters
///
/// If commit time for 2¹⁶ degree is > 200ms, the system may not be suitable
/// for production blockchain use where throughput requirements demand
/// sub-second commitment generation.
#[test]
#[cfg(feature = "test-only")]
fn test_large_polynomial_degree_2_16() {
    let max_degree = 65536; // 2^16
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Generate polynomial with many non-zero coefficients
    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let expected_value = poly.evaluate(&point);

    let opening = Commitment::open(&poly, point, &srs);

    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for degree 2^16 polynomial"
    );

    assert_eq!(
        opening.value, expected_value,
        "Opening value mismatch for degree 2^16 polynomial"
    );
}

/// Test commitment, opening, and verification for a degree 2²⁰ polynomial
///
/// # Mathematical Context
///
/// Degree 2²⁰ = 1,048,576 is a very large polynomial. This is an extreme stress
/// test that validates the implementation handles very large workloads.
///
/// # Real-World Relevance
///
/// - **Large rollups**: Full day's worth of transactions
/// - **Complex zk-SNARK circuits**: Privacy-preserving smart contract suites
/// - **Verkle trees**: Entire state tree for large blockchain
/// - **Data availability**: 16MB data chunks (Ethereum's max transaction size)
///
/// # Performance Expectations
///
/// - Commit time: ~500ms (acceptable for large batches)
/// - Open time: ~300ms
/// - Verify time: < 1ms (constant!)
/// - Memory usage: ~100MB
///
/// # What This Test Validates
///
/// 1. MSM can handle 1M+ coefficients without crashing
/// 2. Memory usage is reasonable (~100MB, not GBs)
/// 3. No integer overflow in internal computations
/// 4. Verification remains constant-time even for huge polynomials
///
/// # Why Constant-Time Verification Matters
///
/// The key advantage of KZG10 is O(1) verification. For a degree 2²⁰ polynomial:
/// - Commitment takes 500ms (prover work)
/// - Verification takes < 1ms (verifier work)
///
/// This 500× speedup is what makes KZG10 suitable for blockchains where
/// verifying nodes must process thousands of transactions per second.
///
/// # Performance Note
///
/// This test may take 1-2 seconds to run. Consider marking it as ignored
/// in rapid CI/CD pipelines.
#[test]
#[cfg(feature = "test-only")]
#[ignore] // May be slow in CI
fn test_large_polynomial_degree_2_20() {
    let max_degree = 1_048_576; // 2^20
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // For performance, use sparse polynomial (only 10% non-zero coefficients)
    let mut coeffs = vec![Fr::from(0u64); max_degree + 1];
    for i in 0..(max_degree / 10) {
        coeffs[i * 10] = Fr::rand(&mut rng);
    }
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let expected_value = poly.evaluate(&point);

    let opening = Commitment::open(&poly, point, &srs);

    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for degree 2^20 polynomial"
    );

    assert_eq!(
        opening.value, expected_value,
        "Opening value mismatch for degree 2^20 polynomial"
    );
}

// ============================================================================
// Section 2: Multi-Point Openings
// ============================================================================

/// Test opening a polynomial at 2 distinct points
///
/// # Mathematical Context
///
/// Multi-point openings validate that a polynomial has specific values at
/// multiple points. This is useful for batching queries.
///
/// # Real-World Relevance
///
/// - **Verkle trees**: Prove values for multiple keys in a trie
/// - **State proofs**: Validate multiple contract state entries
/// - **Batch reads**: Reduce verification overhead for multiple queries
///
/// # What This Test Validates
///
/// 1. Can open the same polynomial at different points
/// 2. Each opening is independently verifiable
/// 3. Different points produce different proofs (not identical)
/// 4. All values match direct polynomial evaluation
#[test]
#[cfg(feature = "test-only")]
fn test_multi_point_opening_2_points() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    // Choose 2 random points
    let points: Vec<Fr> = (0..2)
        .map(|_| Fr::rand(&mut rng))
        .collect();

    // Open at both points
    let openings: Vec<_> = points
        .iter()
        .map(|&point| Commitment::open(&poly, point, &srs))
        .collect();

    // Verify all openings
    for (opening, &point) in openings.iter().zip(points.iter()) {
        let expected_value = poly.evaluate(&point);

        assert!(
            commitment.verify(opening, &srs),
            "Verification failed for multi-point opening at point {:?}",
            point
        );

        assert_eq!(
            opening.value, expected_value,
            "Value mismatch for multi-point opening"
        );
    }

    // Verify that different points produce different proofs
    // (unless by extreme coincidence)
    if openings[0].point != openings[1].point {
        assert_ne!(
            openings[0].proof.witness, openings[1].proof.witness,
            "Different points should produce different proofs"
        );
    }
}

/// Test opening a polynomial at 4 distinct points
///
/// # Real-World Relevance
///
/// - **Verkle tree branches**: Typical branching factor is 4-256
/// - **Batch state queries**: Validate 4 state entries in one batch
/// - **Multi-signature wallets**: Prove balances of multiple participants
///
/// # What This Test Validates
///
/// 1. Consistency: All openings verify correctly
/// 2. Correctness: All values match direct evaluation
/// 3. Efficiency: Can generate multiple proofs without issues
#[test]
#[cfg(feature = "test-only")]
fn test_multi_point_opening_4_points() {
    let max_degree = 1024;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let points: Vec<Fr> = (0..4)
        .map(|_| Fr::rand(&mut rng))
        .collect();

    let openings: Vec<_> = points
        .iter()
        .map(|&point| Commitment::open(&poly, point, &srs))
        .collect();

    for (opening, &point) in openings.iter().zip(points.iter()) {
        let expected_value = poly.evaluate(&point);

        assert!(
            commitment.verify(opening, &srs),
            "Verification failed in 4-point opening"
        );

        assert_eq!(opening.value, expected_value);
    }
}

/// Test opening a polynomial at 8 distinct points
///
/// # Real-World Relevance
///
/// - **Large Verkle tree branches**: Proof for 8 keys in one operation
/// - **Account updates**: Prove balances for 8 accounts
/// - **Transaction batching**: Validate 8 transactions
///
/// # What This Test Validates
///
/// 1. Scalability: Multi-opening works for moderate batches
/// 2. No memory leaks in repeated opening operations
/// 3. Consistent performance across multiple openings
#[test]
#[cfg(feature = "test-only")]
fn test_multi_point_opening_8_points() {
    let max_degree = 2048;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let points: Vec<Fr> = (0..8)
        .map(|_| Fr::rand(&mut rng))
        .collect();

    let openings: Vec<_> = points
        .iter()
        .map(|&point| Commitment::open(&poly, point, &srs))
        .collect();

    for (opening, &point) in openings.iter().zip(points.iter()) {
        let expected_value = poly.evaluate(&point);

        assert!(
            commitment.verify(opening, &srs),
            "Verification failed in 8-point opening"
        );

        assert_eq!(opening.value, expected_value);
    }
}

/// Test opening a polynomial at 16 distinct points
///
/// # Real-World Relevance
///
/// - **Large-scale batch queries**: Verify 16 state entries at once
/// - **Block production**: Prove 16 transactions in a block
/// - **State transitions**: Validate state changes across 16 contracts
///
/// # What This Test Validates
///
/// 1. Can handle larger batches of openings
/// 2. All proofs are independent and verifiable
/// 3. No performance degradation or memory issues
#[test]
#[cfg(feature = "test-only")]
fn test_multi_point_opening_16_points() {
    let max_degree = 4096;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let points: Vec<Fr> = (0..16)
        .map(|_| Fr::rand(&mut rng))
        .collect();

    let openings: Vec<_> = points
        .iter()
        .map(|&point| Commitment::open(&poly, point, &srs))
        .collect();

    for (opening, &point) in openings.iter().zip(points.iter()) {
        let expected_value = poly.evaluate(&point);

        assert!(
            commitment.verify(opening, &srs),
            "Verification failed in 16-point opening"
        );

        assert_eq!(opening.value, expected_value);
    }
}

/// Test batch verification of multiple openings at the same point
///
/// # Mathematical Context
///
/// Batch verification uses random linear combination to verify multiple proofs
/// with a single pairing check, reducing amortized cost by ~3x.
///
/// # Real-World Relevance
///
/// - **Blockchain validation**: Verify 100 transaction proofs in one pairing
/// - **Stateless clients**: Validate multiple state entries efficiently
/// - **Rollup verification**: Batch verify rollup transaction proofs
///
/// # What This Test Validates
///
/// 1. Batch verification works for multiple polynomials at the same point
/// 2. Batch result matches individual verification results
/// 3. Performance improvement is realized (though not explicitly measured here)
///
/// # Security Note
///
/// Batch verification relies on the Fiat-Shamir heuristic: random coefficients
/// prevent attackers from crafting proofs that pass batch check but fail
/// individual checks (except with negligible probability 1/|Fr|).
#[test]
#[cfg(feature = "test-only")]
fn test_batch_verification_same_point() {
    let max_degree = 256;
    let num_polys = 10;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let mut commitments = Vec::new();
    let mut openings = Vec::new();

    // Create multiple polynomials and their openings
    for _ in 0..num_polys {
        let coeffs: Vec<Fr> = (0..=max_degree)
            .map(|_| Fr::rand(&mut rng))
            .collect();
        let poly = DensePolynomial::from_coefficients_vec(coeffs);

        let commitment = Commitment::commit(&poly, &srs);

        // All openings at the same point for batch verification
        let point = Fr::from(42u64); // Fixed point
        let opening = Commitment::open(&poly, point, &srs);

        // Verify individually first
        assert!(
            commitment.verify(&opening, &srs),
            "Individual verification failed"
        );

        commitments.push(commitment);
        openings.push(opening);
    }

    // Batch verify all openings
    let batch_result = batch_verify(&commitments, &openings, &srs)
        .expect("Batch verification failed");

    assert!(
        batch_result,
        "Batch verification failed but individual verifications succeeded"
    );
}

// ============================================================================
// Section 3: Failure Modes (Security Tests)
// ============================================================================

/// Test that verification fails when the value is tampered with
///
/// # Mathematical Context
///
/// Soundness property: If P(z) ≠ v, then verification should fail with
/// overwhelming probability (false acceptance rate ≤ 1/|Fr| ≈ 2^(-254)).
///
/// # Real-World Relevance
///
/// - **Network adversaries**: Malicious node claims false value
/// - **Software bugs**: Bug in value computation
/// - **Data corruption**: Memory corruption modifies value
///
/// # What This Test Validates
///
/// 1. Verification correctly rejects wrong values
/// 2. No edge cases bypass verification
/// 3. Soundness property holds in practice
#[test]
#[cfg(feature = "test-only")]
fn test_tampered_value_rejected() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let mut opening = Commitment::open(&poly, point, &srs);

    // Tamper with the value
    let original_value = opening.value;
    opening.value += Fr::from(1u64);

    // Verification should fail
    assert!(
        !commitment.verify(&opening, &srs),
        "Verification succeeded with tampered value (original: {:?}, tampered: {:?})",
        original_value, opening.value
    );
}

/// Test that verification fails when the commitment is tampered with
///
/// # Mathematical Context
///
/// The commitment C = P(s)·G binds to the polynomial P. Modifying C breaks
/// the binding property, and verification should fail.
///
/// # Real-World Relevance
///
/// - **Storage corruption**: Disk errors corrupt stored commitment
/// - **Network tampering**: Man-in-the-middle modifies commitment
/// - **Software bugs**: Bug in commitment serialization/deserialization
///
/// # What This Test Validates
///
/// 1. Commitment binding works (can't change C without breaking verification)
/// 2. Verification detects commitment modifications
/// 3. No false positives from corrupted commitments
#[test]
#[cfg(feature = "test-only")]
fn test_tampered_commitment_rejected() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let mut commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&poly, point, &srs);

    // Tamper with the commitment by adding the generator
    let g1_gen = <Bls12_381 as Pairing>::G1::generator();
    commitment.0 = (commitment.to_projective() + g1_gen).into_affine();

    // Verification should fail
    assert!(
        !commitment.verify(&opening, &srs),
        "Verification succeeded with tampered commitment"
    );
}

/// Test that verification fails when the proof witness is tampered with
///
/// # Mathematical Context
///
/// The proof π = Q(s)·G where Q = (P-v)/(x-z). Modifying π breaks the
/// proof, and the pairing equation will not hold.
///
/// # Real-World Relevance
///
/// - **Storage corruption**: Disk errors corrupt stored proof
/// - **Network attacks**: Attacker modifies proof in transit
/// - **Software bugs**: Bug in proof computation
///
/// # What This Test Validates
///
/// 1. Proof integrity is enforced by verification
/// 2. Tampered proofs are reliably rejected
/// 3. No edge cases allow forged proofs
#[test]
#[cfg(feature = "test-only")]
fn test_tampered_proof_rejected() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let mut opening = Commitment::open(&poly, point, &srs);

    // Tamper with the proof witness
    let g1_gen = <Bls12_381 as Pairing>::G1::generator();
    opening.proof.witness = (opening.proof.witness + g1_gen).into_affine();

    // Verification should fail
    assert!(
        !commitment.verify(&opening, &srs),
        "Verification succeeded with tampered proof"
    );
}

/// Test that verification fails when the point is incorrect
///
/// # Mathematical Context
///
/// The proof π is computed for a specific point z. Using a different point z'
/// in verification breaks the pairing equation (unless P(z) = P(z') by coincidence).
///
/// # Real-World Relevance
///
/// - **Query confusion**: Verify proof for wrong key/state slot
/// - **Software bugs**: Mix up proof with query for different data
/// - **Protocol errors**: Send proof to wrong verifier
///
/// # What This Test Validates
///
/// 1. Proofs are point-specific
/// 2. Can't reuse proofs for different points
/// 3. Verification checks the point, not just the proof
#[test]
#[cfg(feature = "test-only")]
fn test_wrong_point_rejected() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point1 = Fr::rand(&mut rng);
    let mut opening = Commitment::open(&poly, point1, &srs);

    // Change the point to a different value
    let point2 = Fr::rand(&mut rng);
    opening.point = point2;

    // Verification should fail (unless P(point1) = P(point2), very unlikely)
    if poly.evaluate(&point1) != poly.evaluate(&point2) {
        assert!(
            !commitment.verify(&opening, &srs),
            "Verification succeeded with wrong point"
        );
    }
}

// ============================================================================
// Section 4: Edge Cases and Boundary Conditions
// ============================================================================

/// Test commitment to the zero polynomial
///
/// # Mathematical Context
///
/// The zero polynomial P(x) = 0 has all coefficients zero. Its commitment
/// should be the identity element (zero) in G1.
///
/// # Real-World Relevance
///
/// - **Empty blocks**: Blockchain blocks with no transactions
/// - **Initial state**: Empty Merkle trees or Verkle trees
/// - **Testing**: Edge case in testing frameworks
///
/// # What This Test Validates
///
/// 1. Zero polynomial commits to identity element
/// 2. Opening works for zero polynomial (value is 0)
/// 3. Verification succeeds for zero polynomial
/// 4. No special-casing bugs for zero polynomial
#[test]
#[cfg(feature = "test-only")]
fn test_zero_polynomial() {
    let max_degree = 100;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Zero polynomial: all coefficients are zero
    let zero_poly = DensePolynomial::<Fr>::zero();

    let commitment = Commitment::commit(&zero_poly, &srs);

    // Commitment should be identity (zero) element
    assert!(
        commitment.0.is_zero(),
        "Zero polynomial should commit to identity element"
    );

    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&zero_poly, point, &srs);

    // Value should be zero
    assert_eq!(
        opening.value,
        Fr::from(0u64),
        "Zero polynomial evaluation should be zero"
    );

    // Should verify correctly
    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for zero polynomial"
    );
}

/// Test commitment to a constant polynomial (degree 0)
///
/// # Mathematical Context
///
/// Constant polynomial P(x) = c has degree 0. Commitment is C = c·G.
///
/// # Real-World Relevance
///
/// - **Configuration values**: Store constant configuration in commitments
/// - **Genesis state**: Initial blockchain state with constant values
/// - **Thresholds**: Fixed thresholds in voting systems
///
/// # What This Test Validates
///
/// 1. Degree 0 polynomials work correctly
/// 2. Commitment is c·G as expected
/// 3. Opening returns constant value
/// 4. Verification succeeds
#[test]
#[cfg(feature = "test-only")]
fn test_constant_polynomial() {
    let max_degree = 100;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup.failed");

    let constant = Fr::from(42u64);
    let const_poly = DensePolynomial::from_coefficients_vec(vec![constant]);

    let commitment = Commitment::commit(&const_poly, &srs);

    // Commitment should be constant * G
    let g1_gen = <Bls12_381 as Pairing>::G1::generator();
    let expected_commitment = g1_gen.mul(constant).into_affine();
    assert_eq!(
        commitment.0, expected_commitment,
        "Constant polynomial commitment mismatch"
    );

    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&const_poly, point, &srs);

    // Value should be constant (independent of point)
    assert_eq!(
        opening.value, constant,
        "Constant polynomial evaluation should be constant"
    );

    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for constant polynomial"
    );
}

/// Test commitment at maximum degree
///
/// # Mathematical Context
///
/// Polynomial with degree = SRS.max_degree. This is the boundary case
/// where the polynomial uses all available SRS powers.
///
/// # Real-World Relevance
///
/// - **Capacity planning**: Ensure SRS is large enough for workload
/// - **Resource limits**: Prevent exceeding SRS capacity
/// - **Edge cases**: Ensure no off-by-one errors in degree checks
///
/// # What This Test Validates
///
/// 1. Maximum degree polynomials work correctly
/// 2. All SRS powers are used (no index out of bounds)
/// 3. No performance cliffs at boundary
/// 4. Verification succeeds at max degree
#[test]
#[cfg(feature = "test-only")]
fn test_maximum_degree_polynomial() {
    let max_degree = 1000;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Polynomial with exactly max_degree
    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    assert_eq!(poly.degree(), max_degree, "Polynomial degree mismatch");

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&poly, point, &srs);

    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for maximum degree polynomial"
    );
}

/// Test with special field elements (0, 1, -1, field size - 1)
///
/// # Mathematical Context
///
/// Field elements have special properties:
/// - 0: Additive identity
/// - 1: Multiplicative identity
/// - -1: Additive inverse of 1
/// - p-1: Largest field element (where p is field characteristic)
///
/// These can trigger edge cases in field arithmetic.
///
/// # Real-World Relevance
///
/// - **Corner cases**: Arithmetic edge cases
/// - **Testing**: Validate field operations work for all inputs
/// - **Protocol boundaries**: Ensure no overflow or underflow
///
/// # What This Test Validates
///
/// 1. Special field elements work correctly in commitments
/// 2. No arithmetic bugs with 0, 1, -1
/// 3. No issues with large field elements
/// 4. Verification succeeds for all special values
#[test]
#[cfg(feature = "test-only")]
fn test_special_field_elements() {
    let max_degree = 100;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Test with special coefficient values
    let special_coeffs = vec![
        Fr::from(0u64),
        Fr::from(1u64),
        -Fr::from(1u64),  // -1
    ];

    for &coeff in &special_coeffs {
        let poly = DensePolynomial::from_coefficients_vec(vec![coeff, coeff]);

        let commitment = Commitment::commit(&poly, &srs);

        let point = Fr::from(1u64);
        let opening = Commitment::open(&poly, point, &srs);

        assert!(
            commitment.verify(&opening, &srs),
            "Verification failed for special coefficient {:?}",
            coeff
        );
    }

    // Test with special evaluation points
    let poly = DensePolynomial::from_coefficients_vec(vec![
        Fr::from(1u64), Fr::from(2u64), Fr::from(3u64)
    ]);

    let commitment = Commitment::commit(&poly, &srs);

    let special_points = vec![
        Fr::from(0u64),
        Fr::from(1u64),
        -Fr::from(1u64),
    ];

    for point in special_points {
        let opening = Commitment::open(&poly, point, &srs);

        assert!(
            commitment.verify(&opening, &srs),
            "Verification failed for special point {:?}",
            point
        );
    }
}

// ============================================================================
// Section 5: Homomorphism Property
// ============================================================================

/// Test that commitment is homomorphic (linear)
///
/// # Mathematical Context
///
/// The commitment scheme is homomorphic: Commit(a·P + b·Q) = a·Commit(P) + b·Commit(Q).
/// This property is critical for:
/// - Batch verification
/// - Proof aggregation
/// - Polynomial linear combinations
///
/// # Real-World Relevance
///
/// - **Aggregation**: Combine multiple commitments into one
/// - **Batch operations**: Verify multiple proofs efficiently
/// - **Linear combinations**: Common in SNARK circuits
///
/// # What This Test Validates
///
/// 1. Commitment is linear (homomorphic)
/// 2. Can combine commitments using scalar multiplication and addition
/// 3. Combined commitment matches commitment of combined polynomial
/// 4. This property is used by batch verification
#[test]
#[cfg(feature = "test-only")]
fn test_homomorphic_property() {
    let max_degree = 100;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Create two polynomials
    let poly1_coeffs: Vec<Fr> = (0..=10)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly1 = DensePolynomial::from_coefficients_vec(poly1_coeffs);

    let poly2_coeffs: Vec<Fr> = (0..=10)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly2 = DensePolynomial::from_coefficients_vec(poly2_coeffs);

    // Random scalars
    let a = Fr::rand(&mut rng);
    let b = Fr::rand(&mut rng);

    // Commit to individual polynomials
    let comm1 = Commitment::commit(&poly1, &srs);
    let comm2 = Commitment::commit(&poly2, &srs);

    // Combine commitments: a·C1 + b·C2
    let combined_comm_proj = comm1.to_projective() * a + comm2.to_projective() * b;
    let combined_comm = Commitment::from_projective(combined_comm_proj);

    // Combine polynomials: a·P1 + b·P2
    let mut combined_coeffs = vec![Fr::from(0u64); 11.max(poly1.coeffs.len(), poly2.coeffs.len())];
    for i in 0..poly1.coeffs.len() {
        combined_coeffs[i] += poly1.coeffs[i] * a;
    }
    for i in 0..poly2.coeffs.len() {
        combined_coeffs[i] += poly2.coeffs[i] * b;
    }
    let combined_poly = DensePolynomial::from_coefficients_vec(combined_coeffs);

    // Commit to combined polynomial
    let expected_comm = Commitment::commit(&combined_poly, &srs);

    // Should be equal (homomorphic property)
    assert_eq!(
        combined_comm.0, expected_comm.0,
        "Homomorphic property failed: Commit(a·P1 + b·P2) ≠ a·Commit(P1) + b·Commit(P2)"
    );
}

// ============================================================================
// Section 6: Serialization/Deserialization Roundtrips
// ============================================================================

/// Test commitment serialization and deserialization
///
/// # Mathematical Context
///
/// Commitments are G1 points, which can be serialized to 48 bytes using
/// compressed affine representation.
///
/// # Real-World Relevance
///
/// - **Persistent storage**: Save commitments to database
/// - **Network transmission**: Send commitments over P2P network
/// - **State snapshots**: Save blockchain state with commitments
///
/// # What This Test Validates
///
/// 1. Commitment can be converted to bytes
/// 2. Bytes can be converted back to commitment
/// 3. Round-trip preserves the commitment exactly
/// 4. Verification works after round-trip
#[test]
#[cfg(feature = "test-only")]
fn test_commitment_serialization_roundtrip() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    // Serialize to bytes (affine compressed form)
    let bytes = commitment.0.serialize_to_vec();

    // Should be 48 bytes for compressed G1 point
    assert_eq!(bytes.len(), 48, "G1 point should serialize to 48 bytes");

    // Deserialize from bytes
    let deserialized =
        <Bls12_381 as Pairing>::G1Affine::deserialize_compressed(&bytes[..]);

    assert!(
        deserialized.is_ok(),
        "Failed to deserialize commitment: {:?}",
        deserialized
    );

    let deserialized_commitment = Commitment::new(deserialized.unwrap());

    // Should be identical
    assert_eq!(
        commitment.0, deserialized_commitment.0,
        "Deserialized commitment doesn't match original"
    );

    // Verify that deserialized commitment works
    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&poly, point, &srs);

    assert!(
        deserialized_commitment.verify(&opening, &srs),
        "Verification failed with deserialized commitment"
    );
}

/// Test proof serialization and deserialization
///
/// # Real-World Relevance
///
/// - **Proof storage**: Save proofs to disk/database
/// - **Network transmission**: Send proofs over network
/// - **Proof caching**: Cache proofs for faster verification
///
/// # What This Test Validates
///
/// 1. Proof can be serialized to bytes
/// 2. Bytes can be deserialized back to proof
/// 3. Round-trip preserves proof exactly
/// 4. Verification works after round-trip
#[test]
#[cfg(feature = "test-only")]
fn test_proof_serialization_roundtrip() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    let commitment = Commitment::commit(&poly, &srs);

    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&poly, point, &srs);

    // Serialize proof to bytes
    let proof_bytes = opening.proof.witness.serialize_to_vec();

    assert_eq!(proof_bytes.len(), 48, "G1 point should serialize to 48 bytes");

    // Deserialize proof
    let deserialized_proof =
        <Bls12_381 as Pairing>::G1Affine::deserialize_compressed(&proof_bytes[..]);

    assert!(
        deserialized_proof.is_ok(),
        "Failed to deserialize proof: {:?}",
        deserialized_proof
    );

    // Create new opening with deserialized proof
    let deserialized_opening = Opening {
        point: opening.point,
        value: opening.value,
        proof: kzg10::EvaluationProof {
            witness: deserialized_proof.unwrap(),
        },
    };

    // Verify with deserialized proof
    assert!(
        commitment.verify(&deserialized_opening, &srs),
        "Verification failed with deserialized proof"
    );
}

/// Test SRS serialization and deserialization
///
/// # Real-World Relevance
///
/// - **Trusted setup distribution**: Share SRS from ceremony
/// - **Persistent storage**: Save SRS to disk
/// - **Network distribution**: Distribute SRS to nodes
///
/// # What This Test Validates
///
/// 1. SRS can be serialized
/// 2. SRS can be deserialized
/// 3. Round-trip preserves all SRS data
/// 4. Deserialized SRS works for all operations
///
/// # Performance Note
///
/// This test uses a small SRS (degree 256) for speed. Production SRS
/// (degree 2²⁰) would be ~50MB and too slow for unit tests.
#[test]
#[cfg(feature = "test-only")]
fn test_srs_serialization_roundtrip() {
    let max_degree = 256;
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // Serialize SRS
    let mut srs_bytes = Vec::new();

    // Serialize all G1 powers
    for power in &srs.powers_of_g {
        let mut bytes = power.serialize_to_vec();
        srs_bytes.append(&mut bytes);
    }

    // Serialize all G2 powers
    for power in &srs.powers_of_h {
        let mut bytes = power.serialize_to_vec();
        srs_bytes.append(&mut bytes);
    }

    println!("SRS serialized size: {} bytes", srs_bytes.len());

    // Expected size:
    // - G1 powers: (256+1) * 48 = 12,336 bytes
    // - G2 powers: 2 * 96 = 192 bytes
    // Total: ~12.5KB
    assert!(srs_bytes.len() > 12000, "SRS serialization too small");

    // For now, just verify serialization doesn't panic
    // Full deserialization would require implementing SRS::deserialize()
    // which is beyond the scope of this test
}

// ============================================================================
// Section 7: Memory and Performance
// ============================================================================

/// Test memory efficiency of large polynomial operations
///
/// # Mathematical Context
///
/// Large polynomial commitments require:
/// - Polynomial coefficients: (n+1) * 32 bytes for Fr elements
/// - SRS powers: (n+1) * 48 bytes for G1 elements
/// - Commitment: 48 bytes
/// - Proof: 48 bytes
///
/// For degree 2²⁰: ~32MB + ~50MB = ~82MB
///
/// # Real-World Relevance
///
/// - **Resource planning**: Ensure sufficient memory for operations
/// - **Cost optimization**: Minimize memory usage for cloud deployments
/// - **Scalability**: Handle large workloads without OOM
///
/// # What This Test Validates
///
/// 1. Large polynomials don't cause memory issues
/// 2. Memory is freed after operations (no leaks)
/// 3. Multiple large operations can run sequentially
///
/// # Performance Expectations
///
/// - Degree 2¹⁶: ~10MB memory usage
/// - Operations complete without swapping
/// - No memory leaks (verified with Valgrind/heaptrack in production)
#[test]
#[cfg(feature = "test-only")]
fn test_memory_efficiency_large_polynomial() {
    let max_degree = 65536; // 2^16
    let mut rng = test_rng();

    let secret = Fr::rand(&mut rng);
    let srs = SRS::<Bls12_381>::setup_for_testing(secret, max_degree)
        .expect("Setup failed");

    // This should not cause memory issues
    let coeffs: Vec<Fr> = (0..=max_degree)
        .map(|_| Fr::rand(&mut rng))
        .collect();
    let poly = DensePolynomial::from_coefficients_vec(coeffs);

    // Commit
    let commitment = Commitment::commit(&poly, &srs);

    // Open
    let point = Fr::rand(&mut rng);
    let opening = Commitment::open(&poly, point, &srs);

    // Verify
    assert!(
        commitment.verify(&opening, &srs),
        "Verification failed for memory efficiency test"
    );

    // If we reach here without OOM, memory usage is acceptable
}

/// Test verification is constant-time regardless of degree
///
/// # Mathematical Context
///
/// Verification uses 3 pairings, which take constant time independent of
/// polynomial degree. This is the key advantage of KZG10.
///
/// # Real-World Relevance
///
/// - **Scalability**: Verify thousands of proofs per second
/// - **Predictable latency**: Verification time is bounded
/// - **SLA guarantees**: Can guarantee verification < 1ms
///
/// # What This Test Validates
///
/// 1. Verification time doesn't grow with degree
/// 2. Large and small polynomials verify in similar time
/// 3. Verification is always O(1) pairings
///
/// # Performance Expectations
///
/// All verifications should complete in < 1ms regardless of degree.
///
/// Note: We don't explicitly measure time here (unstable in unit tests),
/// but we verify correctness at all degrees.
#[test]
#[cfg(feature = "test-only")]
fn test_verification_constant_time() {
    let mut rng = test_rng();

    let degrees = vec![10, 100, 1000, 10000];

    for degree in degrees {
        let secret = Fr::rand(&mut rng);
        let srs = SRS::<Bls12_381>::setup_for_testing(secret, degree)
            .expect("Setup failed");

        let coeffs: Vec<Fr> = (0..=degree)
            .map(|_| Fr::rand(&mut rng))
            .collect();
        let poly = DensePolynomial::from_coefficients_vec(coeffs);

        let commitment = Commitment::commit(&poly, &srs);

        let point = Fr::rand(&mut rng);
        let opening = Commitment::open(&poly, point, &srs);

        // Verification should always succeed
        assert!(
            commitment.verify(&opening, &srs),
            "Verification failed for degree {}",
            degree
        );

        // Verification uses exactly 3 pairings regardless of degree
        // (we can't count them easily, but the algorithm is fixed)
    }
}
