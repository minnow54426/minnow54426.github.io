# BIP340 Schnorr Signatures Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a production-ready BIP340 Schnorr signature library in Rust with secp256k1, implementing signing, verification, and batch verification with comprehensive testing.

**Architecture:** Use `k256` crate for battle-tested elliptic curve operations while implementing Schnorr protocol logic ourselves (nonce generation, signing, verification). Type-safe newtype wrappers prevent misuse. Deterministic nonce generation prevents catastrophic reuse bugs.

**Tech Stack:**
- **Curve**: secp256k1 via `k256` crate
- **Hash**: SHA-256 via `sha2` crate
- **Security**: `zeroize` for memory clearing, `subtle` for constant-time ops
- **Testing**: `proptest` for property tests, `secp256k1` crate for cross-validation
- **Benchmarks**: `criterion` crate

---

## Phase 1: Project Foundation

### Task 1.1: Update Cargo.toml with Dependencies

**Files:**
- Modify: `Cargo.toml`

**Step 1: Update dependencies**

Replace the entire `Cargo.toml` with:

```toml
[package]
name = "schnorr"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <you@example.com>"]
description = "BIP340 Schnorr signatures on secp256k1"
license = "MIT OR Apache-2.0"

[dependencies]
k256 = { version = "0.13", features = ["arithmetic", "serde"] }
sha2 = "0.10"
serde = { version = "1.0", features = ["derive"], optional = true }
rand_core = "0.6"
zeroize = "1.5"
subtle = "2.4"

[dev-dependencies]
rand = "0.8"
hex = "0.4"
proptest = "1.0"
criterion = "0.5"
secp256k1 = "0.27"

[[bench]]
name = "schnorr_bench"
harness = false
```

**Step 2: Verify dependencies resolve**

Run: `cargo check`
Expected: "Compiling schnorr v0.1.0" then "Finished"

**Step 3: Commit**

```bash
git add Cargo.toml
git commit -m "feat(schnorr): add dependencies (k256, sha2, zeroize, subtle)"
```

---

### Task 1.2: Create Module Structure

**Files:**
- Modify: `src/lib.rs`
- Create: `src/error.rs`
- Create: `src/keypair.rs`
- Create: `src/signature.rs`
- Create: `src/nonce.rs`
- Create: `src/challenge.rs`
- Create: `src/sign.rs`
- Create: `src/verify.rs`

**Step 1: Write module declarations**

Replace `src/lib.rs` with:

```rust
//! BIP340 Schnorr signatures on secp256k1
//!
//! This library implements the Schnorr signature scheme as specified in BIP340:
//! <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
//!
//! # Features
//!
//! - Deterministic nonce generation (prevents nonce reuse)
//! - Single and batch verification
//! - Type-safe API (newtype wrappers prevent misuse)
//! - Constant-time operations (timing attack resistant)
//!
//! # Example
//!
//! ```no_run
//! use schnorr::{KeyPair, rand::rngs::OsRng};
//!
//! let mut rng = OsRng;
//! let keypair = KeyPair::new(&mut rng);
//! let message = b"Hello, Schnorr!";
//! let signature = keypair.sign(message);
//!
//! assert!(keypair.public_key().verify(message, &signature).is_ok());
//! ```

pub mod error;
pub mod keypair;
pub mod signature;

mod nonce;
mod challenge;
mod sign;
mod verify;

// Re-export public types
pub use keypair::{KeyPair, SecretKey, PublicKey};
pub use signature::Signature;
pub use error::Error;
```

**Step 2: Create stub modules**

Create each file with a basic stub:

`src/error.rs`:
```rust
//! Error types for Schnorr operations

use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum Error {
    InvalidSecretKey,
    InvalidPublicKey,
    InvalidSignature,
    InvalidNonce,
    InvalidEncoding,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::InvalidSecretKey => write!(f, "Invalid secret key"),
            Error::InvalidPublicKey => write!(f, "Invalid public key"),
            Error::InvalidSignature => write!(f, "Invalid signature"),
            Error::InvalidNonce => write!(f, "Invalid nonce"),
            Error::InvalidEncoding => write!(f, "Invalid encoding"),
        }
    }
}

impl std::error::Error for Error {}
```

`src/keypair.rs`:
```rust
//! Key types: SecretKey, PublicKey, KeyPair

// Placeholder - will implement in Task 2
```

`src/signature.rs`:
```rust
//! Signature type

// Placeholder - will implement in Task 2
```

`src/nonce.rs`, `src/challenge.rs`, `src/sign.rs`, `src/verify.rs`:
```rust
// Placeholder - will implement later
```

**Step 3: Verify module structure compiles**

Run: `cargo check`
Expected: "Finished" (no errors)

**Step 4: Commit**

```bash
git add src/
git commit -m "feat(schnorr): create module structure"
```

---

## Phase 2: Core Types

### Task 2.1: Implement Error Type

**Files:**
- Modify: `src/error.rs`

**Step 1: Write error implementation**

Replace `src/error.rs` with:

```rust
//! Error types for Schnorr operations
//!
//! This module defines the error types used throughout the library.

use std::fmt;

/// Errors that can occur during Schnorr operations
#[derive(Debug, Clone, PartialEq)]
pub enum Error {
    /// Secret key is invalid (scalar is 0 or >= curve order)
    InvalidSecretKey,

    /// Public key is invalid (point not on curve or at infinity)
    InvalidPublicKey,

    /// Signature verification failed
    InvalidSignature,

    /// Nonce generation failed (nonce is 0)
    InvalidNonce,

    /// Invalid byte encoding (wrong length, parse error)
    InvalidEncoding,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::InvalidSecretKey => write!(f, "Invalid secret key: scalar must be in [1, n-1]"),
            Error::InvalidPublicKey => write!(f, "Invalid public key: point not on curve"),
            Error::InvalidSignature => write!(f, "Invalid signature: verification failed"),
            Error::InvalidNonce => write!(f, "Invalid nonce: nonce cannot be zero"),
            Error::InvalidEncoding => write!(f, "Invalid encoding: byte sequence malformed"),
        }
    }
}

impl std::error::Error for Error {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_display() {
        assert_eq!(Error::InvalidSecretKey.to_string(), "Invalid secret key: scalar must be in [1, n-1]");
        assert_eq!(Error::InvalidPublicKey.to_string(), "Invalid public key: point not on curve");
    }

    #[test]
    fn test_error_equality() {
        assert_eq!(Error::InvalidSignature, Error::InvalidSignature);
        assert_ne!(Error::InvalidSignature, Error::InvalidNonce);
    }
}
```

**Step 2: Run tests**

Run: `cargo test error`
Expected: "test result: ok. 2 passed"

**Step 3: Commit**

```bash
git add src/error.rs
git commit -m "feat(error): implement Error type with tests"
```

---

### Task 2.2: Implement SecretKey

**Files:**
- Modify: `src/keypair.rs`

**Step 1: Write failing test for SecretKey**

Add to `src/keypair.rs`:

```rust
//! Key types: SecretKey, PublicKey, KeyPair
//!
//! This module implements the key types for Schnorr signatures.

use crate::Error;
use k256::Scalar;
use rand_core::CryptoRng;
use zeroize::Zeroize;

/// Secret key for Schnorr signatures
///
/// This is a wrapper around a scalar value x in [1, n-1] where n is the curve order.
/// The public key is P = x*G where G is the generator.
///
/// # Security
///
/// - Secrets are never serialized (use `to_bytes` only for secure backup)
/// - Secrets are zeroized on drop
/// - All operations are constant-time
pub struct SecretKey(Scalar);

impl SecretKey {
    /// Generate a random secret key
    ///
    /// # Arguments
    ///
    /// * `rng` - Random number generator (must be cryptographically secure)
    pub fn random(rng: &mut impl CryptoRng) -> Self {
        // Generate random bytes and interpret as scalar
        let mut bytes = [0u8; 32];
        rng.fill_bytes(&mut bytes);

        // Reduce modulo curve order to ensure scalar is in valid range
        let scalar = Scalar::from_bytes_reduced(&bytes);

        // Ensure scalar is not zero (extremely unlikely, but handle it)
        if scalar.is_zero().into() {
            // Retry with different bytes
            return Self::random(rng);
        }

        SecretKey(scalar)
    }

    /// Create a secret key from bytes
    ///
    /// # Arguments
    ///
    /// * `bytes` - 32-byte array
    ///
    /// # Returns
    ///
    /// Returns `Error::InvalidSecretKey` if the scalar is 0 or >= curve order
    pub fn from_bytes(bytes: &[u8; 32]) -> Result<Self, Error> {
        let scalar = Scalar::from_bytes_reduced(bytes);

        if scalar.is_zero().into() {
            return Err(Error::InvalidSecretKey);
        }

        Ok(SecretKey(scalar))
    }

    /// Export secret key as bytes (use only for secure backup!)
    ///
    /// # Security Warning
    ///
    /// This exports the raw secret key. Only use this for secure backup.
    /// Never log or transmit these bytes.
    pub fn to_bytes(&self) -> [u8; 32] {
        self.0.to_bytes()
    }

    /// Get reference to the underlying scalar (internal use only)
    fn as_scalar(&self) -> &Scalar {
        &self.0
    }
}

// Drop implementation to zeroize secret data
impl Drop for SecretKey {
    fn drop(&mut self) {
        self.0.zeroize();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;

    #[test]
    fn test_secret_key_random() {
        let mut rng = OsRng;
        let sk = SecretKey::random(&mut rng);
        let bytes = sk.to_bytes();

        // Should be 32 bytes
        assert_eq!(bytes.len(), 32);

        // Should not be all zeros
        assert_ne!(bytes, [0u8; 32]);
    }

    #[test]
    fn test_secret_key_from_bytes() {
        let bytes = [1u8; 32];
        let sk = SecretKey::from_bytes(&bytes).unwrap();

        assert_eq!(sk.to_bytes(), bytes);
    }

    #[test]
    fn test_secret_key_zero_bytes_fails() {
        let bytes = [0u8; 32];
        let result = SecretKey::from_bytes(&bytes);

        assert_eq!(result, Err(Error::InvalidSecretKey));
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test secret_key`
Expected: Compilation errors (types not implemented yet)

**Step 3: Fix any compilation errors**

The code above should compile. If there are issues, fix them.

**Step 4: Run test to verify it passes**

Run: `cargo test secret_key`
Expected: "test result: ok. 3 passed"

**Step 5: Commit**

```bash
git add src/keypair.rs
git commit -m "feat(keypair): implement SecretKey with tests"
```

---

### Task 2.3: Implement PublicKey

**Files:**
- Modify: `src/keypair.rs`

**Step 1: Write failing test for PublicKey**

Add to `src/keypair.rs` (after SecretKey implementation):

```rust
use k256::{AffinePoint, ProjectivePoint, sec1::EncodedPoint};

/// Public key for Schnorr signatures
///
/// This is a point P = x*G on the secp256k1 curve where x is the secret key.
/// Stored as an affine point for efficient verification.
pub struct PublicKey(AffinePoint);

impl PublicKey {
    /// Derive a public key from a secret key
    ///
    /// Computes P = x*G where x is the secret key and G is the generator.
    pub fn from_secret_key(secret: &SecretKey) -> Self {
        let point = ProjectivePoint::GENERATOR * secret.as_scalar();
        PublicKey(point.to_affine())
    }

    /// Parse a public key from compressed SEC encoding
    ///
    /// # Arguments
    ///
    /// * `bytes` - 33-byte compressed SEC encoding
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        if bytes.len() != 33 {
            return Err(Error::InvalidEncoding);
        }

        let encoded = EncodedPoint::from_bytes(bytes)
            .map_err(|_| Error::InvalidEncoding)?;

        let point = AffinePoint::from_encoded_point(&encoded)
            .into_option()
            .ok_or(Error::InvalidPublicKey)?;

        // Check that point is not infinity
        if point.is_identity().into() {
            return Err(Error::InvalidPublicKey);
        }

        Ok(PublicKey(point))
    }

    /// Serialize public key to compressed SEC encoding
    pub fn to_bytes(&self) -> [u8; 33] {
        let encoded = EncodedPoint::from(self.0);
        let mut bytes = [0u8; 33];
        bytes.copy_from_slice(encoded.as_bytes());
        bytes
    }

    /// Get reference to the underlying affine point (internal use)
    fn as_affine(&self) -> &AffinePoint {
        &self.0
    }

    /// Get as projective point (for verification)
    fn as_projective(&self) -> ProjectivePoint {
        ProjectivePoint::from(self.0)
    }
}

#[cfg(test)]
mod tests {
    // ... existing tests ...

    use super::*;

    #[test]
    fn test_public_key_from_secret() {
        let mut rng = OsRng;
        let secret = SecretKey::random(&mut rng);
        let public = PublicKey::from_secret_key(&secret);

        // Public key should be 33 bytes (compressed SEC encoding)
        let bytes = public.to_bytes();
        assert_eq!(bytes.len(), 33);

        // First byte should be 0x02 or 0x03 (compressed encoding)
        assert!(bytes[0] == 0x02 || bytes[0] == 0x03);
    }

    #[test]
    fn test_public_key_roundtrip() {
        let mut rng = OsRng;
        let secret = SecretKey::random(&mut rng);
        let public1 = PublicKey::from_secret_key(&secret);

        let bytes = public1.to_bytes();
        let public2 = PublicKey::from_bytes(&bytes).unwrap();

        assert_eq!(public1.to_bytes(), public2.to_bytes());
    }

    #[test]
    fn test_public_key_invalid_bytes() {
        // Wrong length
        let result = PublicKey::from_bytes(&[0x02; 32]);
        assert_eq!(result, Err(Error::InvalidEncoding));
    }
}
```

**Step 2: Run test to verify it compiles and passes**

Run: `cargo test public_key`
Expected: "test result: ok. 3 passed"

**Step 3: Commit**

```bash
git add src/keypair.rs
git commit -m "feat(keypair): implement PublicKey with tests"
```

---

### Task 2.4: Implement Signature

**Files:**
- Modify: `src/signature.rs`

**Step 1: Write Signature implementation**

Replace `src/signature.rs` with:

```rust
//! Signature type
//!
//! Schnorr signature as (r, s) where r is the x-coordinate of R = k*G
//! and s = k + H(R||P||m)*x

use crate::Error;
use k256::Scalar;

/// Schnorr signature
///
/// A Schnorr signature consists of two components:
/// - `r`: The x-coordinate of the commitment point R = k*G
/// - `s`: The response scalar s = k + H(R||P||m)*x
///
/// Both are 32-byte arrays.
#[derive(Debug, Clone, PartialEq)]
pub struct Signature {
    pub r: [u8; 32],
    pub s: [u8; 32],
}

impl Signature {
    /// Create a signature from 64 bytes
    ///
    /// # Arguments
    ///
    /// * `bytes` - 64-byte array (32 bytes for r, 32 bytes for s)
    pub fn from_bytes(bytes: &[u8; 64]) -> Result<Self, Error> {
        let mut sig = Signature {
            r: [0u8; 32],
            s: [0u8; 32],
        };

        sig.r.copy_from_slice(&bytes[0..32]);
        sig.s.copy_from_slice(&bytes[32..64]);

        // Validate signature
        if !sig.is_valid() {
            return Err(Error::InvalidSignature);
        }

        Ok(sig)
    }

    /// Serialize signature to 64 bytes
    pub fn to_bytes(&self) -> [u8; 64] {
        let mut bytes = [0u8; 64];
        bytes[0..32].copy_from_slice(&self.r);
        bytes[32..64].copy_from_slice(&self.s);
        bytes
    }

    /// Validate signature components
    ///
    /// Checks that:
    /// - s is not zero
    /// - s is less than curve order (implicitly checked by scalar reduction)
    fn is_valid(&self) -> bool {
        // Check that s is not zero
        let s = Scalar::from_bytes_reduced(&self.s);
        !s.is_zero().into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signature_roundtrip() {
        let mut r = [0u8; 32];
        let mut s = [0u8; 32];
        r[0] = 0x01;
        s[0] = 0x02;

        let sig1 = Signature { r, s };
        let bytes = sig1.to_bytes();
        let sig2 = Signature::from_bytes(&bytes).unwrap();

        assert_eq!(sig1, sig2);
    }

    #[test]
    fn test_signature_zero_s_fails() {
        let bytes = [1u8; 32]; // r is valid
        let mut sig_bytes = [0u8; 64];
        sig_bytes[0..32].copy_from_slice(&bytes);
        // s is all zeros - should fail

        let result = Signature::from_bytes(&sig_bytes);
        assert_eq!(result, Err(Error::InvalidSignature));
    }
}
```

**Step 2: Run tests**

Run: `cargo test signature`
Expected: "test result: ok. 2 passed"

**Step 3: Commit**

```bash
git add src/signature.rs
git commit -m "feat(signature): implement Signature type with tests"
```

---

### Task 2.5: Implement KeyPair

**Files:**
- Modify: `src/keypair.rs`

**Step 1: Add KeyPair implementation**

Add to `src/keypair.rs` (after PublicKey):

```rust
/// A key pair for Schnorr signatures
///
/// Combines a secret key and its derived public key.
pub struct KeyPair {
    secret: SecretKey,
    public: PublicKey,
}

impl KeyPair {
    /// Generate a new random key pair
    pub fn new(rng: &mut impl CryptoRng) -> Self {
        let secret = SecretKey::random(rng);
        let public = PublicKey::from_secret_key(&secret);
        KeyPair { secret, public }
    }

    /// Get the secret key
    pub fn secret_key(&self) -> &SecretKey {
        &self.secret
    }

    /// Get the public key
    pub fn public_key(&self) -> &PublicKey {
        &self.public
    }

    /// Create a KeyPair from an existing secret key
    pub fn from_secret(secret: SecretKey) -> Self {
        let public = PublicKey::from_secret_key(&secret);
        KeyPair { secret, public }
    }
}

#[cfg(test)]
mod tests {
    // ... existing tests ...

    #[test]
    fn test_keypair_generation() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);

        // Should have both secret and public keys
        let _ = keypair.secret_key();
        let pub_bytes = keypair.public_key().to_bytes();

        assert_eq!(pub_bytes.len(), 33);
    }

    #[test]
    fn test_keypair_from_secret() {
        let mut rng = OsRng;
        let secret1 = SecretKey::random(&mut rng);
        let keypair = KeyPair::from_secret(secret1.clone());

        assert_eq!(keypair.secret_key().to_bytes(), secret1.to_bytes());
    }
}
```

**Step 2: Run tests**

Run: `cargo test keypair`
Expected: All tests pass

**Step 3: Commit**

```bash
git add src/keypair.rs
git commit -m "feat(keypair): implement KeyPair with tests"
```

---

## Phase 3: Cryptography Core

### Task 3.1: Implement Nonce Generation

**Files:**
- Modify: `src/nonce.rs`

**Step 1: Write nonce generation implementation**

Replace `src/nonce.rs` with:

```rust
//! Deterministic nonce generation for Schnorr signatures
//!
//! This is the most security-critical component. Nonce reuse is catastrophic.
//!
//! Algorithm: nonce = SHA256("BIP340/nonce" || secret_key || message || aux_rand)

use crate::SecretKey;
use k256::Scalar;
use rand_core::CryptoRng;
use sha2::{Sha256, Digest};

/// Generate a deterministic nonce for Schnorr signing
///
/// # Security
///
/// This function uses a deterministic algorithm to prevent nonce reuse,
/// which would catastrophically leak the secret key.
///
/// # Algorithm
///
/// ```text
/// nonce = SHA256("BIP340/nonce" || secret_key || message || aux_rand)
/// ```
///
/// Where aux_rand provides additional randomness as defense-in-depth.
pub fn generate_nonce(
    secret_key: &SecretKey,
    message: &[u8],
    rng: &mut impl CryptoRng,
) -> Scalar {
    // Domain separation tag
    let mut hasher = Sha256::new();
    hasher.update(b"BIP340/nonce");

    // Input: secret key bytes
    hasher.update(secret_key.to_bytes());

    // Input: message
    hasher.update(message);

    // Input: auxiliary random data (defense-in-depth)
    let mut aux_rand = [0u8; 32];
    rng.fill_bytes(&mut aux_rand);
    hasher.update(&aux_rand);

    // Output: 32 bytes, interpret as scalar
    let hash = hasher.finalize();

    // Convert to scalar and reduce mod n
    let mut nonce_bytes = [0u8; 32];
    nonce_bytes.copy_from_slice(&hash);

    let scalar = Scalar::from_bytes_reduced(&nonce_bytes);

    // Fallback: if scalar is 0, retry once (extremely unlikely)
    if scalar.is_zero().into() {
        // Return a different nonce using aux_rand modified
        let fallback_scalar = Scalar::from(1u32) + Scalar::from_bytes_reduced(&aux_rand);
        return fallback_scalar;
    }

    scalar
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;

    #[test]
    fn test_nonce_deterministic_same_aux() {
        let secret_bytes = [1u8; 32];
        let secret = SecretKey::from_bytes(&secret_bytes).unwrap();
        let message = b"test message";

        let mut rng1 = OsRng;
        let mut rng2 = OsRng;

        // Different aux_random should give different nonces (probabilistically)
        let nonce1 = generate_nonce(&secret, message, &mut rng1);
        let nonce2 = generate_nonce(&secret, message, &mut rng2);

        // Almost certainly different
        assert_ne!(nonce1.to_bytes(), nonce2.to_bytes());
    }

    #[test]
    fn test_nonce_never_zero() {
        let secret_bytes = [1u8; 32];
        let secret = SecretKey::from_bytes(&secret_bytes).unwrap();
        let message = b"test";

        let mut rng = OsRng;
        for _ in 0..100 {
            let nonce = generate_nonce(&secret, message, &mut rng);
            assert!(!nonce.is_zero().into());
        }
    }
}
```

**Step 2: Run tests**

Run: `cargo test nonce`
Expected: "test result: ok. 2 passed"

**Step 3: Commit**

```bash
git add src/nonce.rs
git commit -m "feat(crypto): implement deterministic nonce generation with tests"
```

---

### Task 3.2: Implement Challenge Computation

**Files:**
- Modify: `src/challenge.rs`

**Step 1: Write challenge computation**

Replace `src/challenge.rs` with:

```rust
//! Challenge computation for Schnorr signatures
//!
//! Challenge e = SHA256("BIP340/challenge" || r || P || m)
//!
//! Domain separation prevents cross-protocol attacks.

use k256::Scalar;
use sha2::{Sha256, Digest};

/// Compute the Schnorr challenge scalar
///
/// # Algorithm
///
/// ```text
/// e = SHA256("BIP340/challenge" || r || P || m)
/// ```
///
/// Where:
/// - r is the x-coordinate of commitment point R
/// - P is the public key (33 bytes compressed)
/// - m is the message
///
/// # Arguments
///
/// * `r_bytes` - 32-byte x-coordinate of R
/// * `public_key` - 33-byte compressed public key
/// * `message` - Message to sign
pub fn compute(
    r_bytes: &[u8; 32],
    public_key: &[u8; 33],
    message: &[u8],
) -> Scalar {
    let mut hasher = Sha256::new();

    // Domain separation tag
    hasher.update(b"BIP340/challenge");

    // r: x-coordinate of R
    hasher.update(r_bytes);

    // P: public key (compressed)
    hasher.update(public_key);

    // m: message
    hasher.update(message);

    let hash = hasher.finalize();

    // Convert to scalar
    Scalar::from_bytes_reduced(&hash)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_challenge_deterministic() {
        let r = [1u8; 32];
        let pk = [2u8; 33];
        let msg = b"test";

        let e1 = compute(&r, &pk, msg);
        let e2 = compute(&r, &pk, msg);

        assert_eq!(e1.to_bytes(), e2.to_bytes());
    }

    #[test]
    fn test_challenge_different_messages() {
        let r = [1u8; 32];
        let pk = [2u8; 33];

        let e1 = compute(&r, &pk, b"message1");
        let e2 = compute(&r, &pk, b"message2");

        assert_ne!(e1.to_bytes(), e2.to_bytes());
    }
}
```

**Step 2: Run tests**

Run: `cargo test challenge`
Expected: "test result: ok. 2 passed"

**Step 3: Commit**

```bash
git add src/challenge.rs
git commit -m "feat(crypto): implement challenge computation with tests"
```

---

### Task 3.3: Implement Signing Algorithm

**Files:**
- Modify: `src/sign.rs`

**Step 1: Write signing implementation**

Replace `src/sign.rs` with:

```rust
//! Schnorr signing algorithm
//!
//! s = k + H(R||P||m)*x
//!
//! Where:
//! - k is the nonce
//! - R = k*G is the commitment
//! - r is the x-coordinate of R
//! - e = H(R||P||m) is the challenge
//! - x is the secret key

use crate::{KeyPair, Signature};
use crate::nonce;
use crate::challenge;
use k256::{ProjectivePoint, Scalar};

impl KeyPair {
    /// Sign a message
    ///
    /// # Algorithm
    ///
    /// 1. Generate nonce k
    /// 2. Compute R = k*G
    /// 3. Extract r = x-coordinate of R
    /// 4. Compute challenge e = H(R||P||m)
    /// 5. Compute s = k + e*x
    /// 6. Return signature (r, s)
    ///
    /// # Arguments
    ///
    /// * `message` - Message to sign
    pub fn sign(&self, message: &[u8]) -> Signature {
        use rand::rngs::OsRng;

        // Step 1: Generate nonce k
        let mut rng = OsRng;
        let k = nonce::generate_nonce(&self.secret, message, &mut rng);

        // Step 2: Compute R = k*G
        let R = ProjectivePoint::GENERATOR * k;

        // Step 3: Extract r = x-coordinate of R
        let R_affine = R.to_affine();
        let r_bytes = R_affine.x.to_bytes();

        // Step 4: Compute challenge e = H(R||P||m)
        let public_bytes = self.public.to_bytes();
        let e = challenge::compute(&r_bytes, &public_bytes, message);

        // Step 5: Compute s = k + e*x
        let x = self.secret.as_scalar();
        let s = k + (e * x);

        // Step 6: Output signature
        Signature {
            r: r_bytes,
            s: s.to_bytes(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;

    #[test]
    fn test_sign_creates_valid_signature() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let message = b"test message";

        let signature = keypair.sign(message);

        // Signature should have valid length
        assert_eq!(signature.r.len(), 32);
        assert_eq!(signature.s.len(), 32);
    }

    #[test]
    fn test_sign_deterministic_same_inputs() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let message = b"deterministic test";

        // Sign twice (note: aux_rand will differ, so signatures will differ)
        let sig1 = keypair.sign(message);
        let sig2 = keypair.sign(message);

        // Due to aux_rand, signatures will differ (this is OK!)
        // But both should be valid
        assert!(sig1.is_valid());
        assert!(sig2.is_valid());
    }
}
```

**Step 2: Run tests**

Run: `cargo test sign`
Expected: "test result: ok. 2 passed"

**Step 3: Commit**

```bash
git add src/sign.rs
git commit -m "feat(sign): implement Schnorr signing algorithm with tests"
```

---

## Phase 4: Verification

### Task 4.1: Implement Single Signature Verification

**Files:**
- Modify: `src/verify.rs`

**Step 1: Write verification implementation**

Replace `src/verify.rs` with:

```rust
//! Schnorr signature verification
//!
//! Verification equation: s*G = R + e*P
//!
//! If this holds, the signature is valid.

use crate::{PublicKey, Signature, Error};
use crate::challenge;
use k256::{Scalar, ProjectivePoint, AffinePoint};
use sha2::{Sha256, Digest};

impl PublicKey {
    /// Verify a signature
    ///
    /// # Algorithm
    ///
    /// 1. Validate signature format
    /// 2. Parse r and s as scalars
    /// 3. Compute challenge e = H(R||P||m)
    /// 4. Verify: s*G = R + e*P
    ///
    /// # Arguments
    ///
    /// * `message` - Message that was signed
    /// * `signature` - Signature to verify
    pub fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), Error> {
        // Step 1: Validate signature
        if !signature.is_valid() {
            return Err(Error::InvalidSignature);
        }

        // Step 2: Parse s as scalar
        let s = Scalar::from_bytes_reduced(&signature.s);

        // Check s is not zero
        if s.is_zero().into() {
            return Err(Error::InvalidSignature);
        }

        // Step 3: Compute challenge
        let e = challenge::compute(&signature.r, &self.to_bytes(), message);

        // Step 4: Verify s*G = R + e*P
        // Left side: s*G
        let sG = ProjectivePoint::GENERATOR * s;

        // Right side: R + e*P
        let R = Self::recover_point_from_x(&signature.r)?;
        let eP = self.as_projective() * e;
        let rhs = R + eP;

        // Check equality
        if sG.eq(&rhs) {
            Ok(())
        } else {
            Err(Error::InvalidSignature)
        }
    }

    /// Recover point from x-coordinate (with even y)
    ///
    /// This reconstructs R from just the x-coordinate r.
    /// Uses the point with even y-coordinate (BIP340 convention).
    fn recover_point_from_x(x_bytes: &[u8; 32]) -> Result<ProjectivePoint, Error> {
        use k256::sec1::EncodedPoint;

        // Try even y-coordinate
        let encoded = EncodedPoint::from_affine_coordinate(
            x_bytes.into(),
            &false,
        );

        AffinePoint::from_encoded_point(&encoded)
            .into_option()
            .map(ProjectivePoint::from)
            .ok_or(Error::InvalidPublicKey)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::KeyPair;
    use rand::rngs::OsRng;

    #[test]
    fn test_verify_valid_signature() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let message = b"test message";

        let signature = keypair.sign(message);

        assert!(keypair.public_key().verify(message, &signature).is_ok());
    }

    #[test]
    fn test_verify_wrong_message_fails() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let signature = keypair.sign(b"message1");

        assert!(keypair.public_key().verify(b"message2", &signature).is_err());
    }

    #[test]
    fn test_verify_wrong_key_fails() {
        let mut rng = OsRng;
        let keypair1 = KeyPair::new(&mut rng);
        let keypair2 = KeyPair::new(&mut rng);

        let signature = keypair1.sign(b"message");

        assert!(keypair2.public_key().verify(b"message", &signature).is_err());
    }

    #[test]
    fn test_verify_tampered_signature_fails() {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let mut signature = keypair.sign(b"message");

        // Tamper with s
        signature.s[0] ^= 0x01;

        assert!(keypair.public_key().verify(b"message", &signature).is_err());
    }
}
```

**Step 2: Run tests**

Run: `cargo test verify`
Expected: "test result: ok. 4 passed"

**Step 3: Commit**

```bash
git add src/verify.rs
git commit -m "feat(verify): implement single signature verification with tests"
```

---

### Task 4.2: Implement Batch Verification

**Files:**
- Modify: `src/verify.rs`

**Step 1: Add batch verification**

Add to `src/verify.rs`:

```rust
use std::ops::Mul;

/// Verify multiple signatures efficiently
///
/// # Algorithm
///
/// Œ£(a·µ¢*s·µ¢)*G = Œ£(a·µ¢*R·µ¢) + Œ£(a·µ¢*e·µ¢*P·µ¢)
///
/// Where a·µ¢ are random coefficients to prevent fraud proofs.
///
/// # Arguments
///
/// * `batch` - Slice of (message, public_key, signature) tuples
pub fn verify_batch(
    batch: &[(Vec<u8>, PublicKey, Signature)]
) -> Result<(), Error> {
    if batch.is_empty() {
        return Ok(());
    }

    use rand::rngs::OsRng;
    let mut rng = OsRng;

    // Generate random coefficients
    let coefficients: Vec<Scalar> = batch.iter()
        .map(|_| {
            let mut bytes = [0u8; 32];
            rng.fill_bytes(&mut bytes);
            Scalar::from_bytes_reduced(&bytes)
        })
        .collect();

    // Compute both sides of the equation
    let mut lhs = ProjectivePoint::IDENTITY;
    let mut rhs = ProjectivePoint::IDENTITY;

    for (i, (msg, pub_key, sig)) in batch.iter().enumerate() {
        let a = &coefficients[i];

        // Parse signature
        let s = Scalar::from_bytes_reduced(&sig.s);

        // Compute challenge
        let e = challenge::compute(&sig.r, &pub_key.to_bytes(), msg);

        // Left side: Œ£(a·µ¢ * s·µ¢) * G
        lhs = lhs + (ProjectivePoint::GENERATOR * (a * s));

        // Right side: Œ£(a·µ¢ * R·µ¢) + Œ£(a·µ¢ * e·µ¢ * P·µ¢)
        let R = PublicKey::recover_point_from_x(&sig.r)?;
        rhs = rhs + (R * a);
        rhs = rhs + (pub_key.as_projective() * (a * e));
    }

    if lhs.eq(&rhs) {
        Ok(())
    } else {
        Err(Error::InvalidSignature)
    }
}

// Add batch verification tests
#[cfg(test)]
mod tests {
    // ... existing tests ...

    #[test]
    fn test_batch_verify_all_valid() {
        let items: Vec<_> = (0..10)
            .map(|_| {
                let mut rng = OsRng;
                let kp = KeyPair::new(&mut rng);
                let msg = b"batch test";
                (msg.to_vec(), kp.public_key().clone(), kp.sign(msg))
            })
            .collect();

        assert!(verify_batch(&items).is_ok());
    }

    #[test]
    fn test_batch_verify_one_invalid_fails() {
        let mut items: Vec<_> = (0..9)
            .map(|_| {
                let mut rng = OsRng;
                let kp = KeyPair::new(&mut rng);
                let msg = b"batch test";
                (msg.to_vec(), kp.public_key().clone(), kp.sign(msg))
            })
            .collect();

        // Add one invalid signature
        let mut rng = OsRng;
        let kp = KeyPair::new(&mut rng);
        let mut sig = kp.sign(b"different message");
        sig.s[0] ^= 0x01; // Tamper
        items.push((b"batch test".to_vec(), kp.public_key().clone(), sig));

        assert!(verify_batch(&items).is_err());
    }
}
```

**Step 2: Update lib.rs to export batch verification**

Add to `src/lib.rs`:
```rust
pub use verify::verify_batch;
```

**Step 3: Run tests**

Run: `cargo test batch`
Expected: "test result: ok. 2 passed"

**Step 4: Commit**

```bash
git add src/verify.rs src/lib.rs
git commit -m "feat(verify): implement batch verification with tests"
```

---

## Phase 5: Testing and Validation

### Task 5.1: Add Integration Tests

**Files:**
- Create: `tests/integration_test.rs`

**Step 1: Write integration test**

Create `tests/integration_test.rs`:

```rust
//! Integration tests for Schnorr signatures

use schnorr::{KeyPair, Signature, PublicKey, verify_batch};
use rand::rngs::OsRng;

#[test]
fn test_end_to_end_sign_verify() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let message = b"Hello, Schnorr!";

    let signature = keypair.sign(message);
    assert!(keypair.public_key().verify(message, &signature).is_ok());
}

#[test]
fn test_multiple_messages_same_key() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);

    let messages = vec![b"msg1", b"msg2", b"msg3"];

    for msg in messages {
        let sig = keypair.sign(msg);
        assert!(keypair.public_key().verify(msg, &sig).is_ok());
    }
}

#[test]
fn test_key_serialization_roundtrip() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);

    let pub_bytes = keypair.public_key().to_bytes();
    let pub_restored = PublicKey::from_bytes(&pub_bytes).unwrap();

    assert_eq!(keypair.public_key().to_bytes(), pub_restored.to_bytes());

    // Verify that restored key works
    let msg = b"test";
    let sig = keypair.sign(msg);
    assert!(pub_restored.verify(msg, &sig).is_ok());
}

#[test]
fn test_signature_serialization_roundtrip() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let msg = b"test";

    let sig1 = keypair.sign(msg);
    let bytes = sig1.to_bytes();
    let sig2 = Signature::from_bytes(&bytes).unwrap();

    assert_eq!(sig1, sig2);
    assert!(keypair.public_key().verify(msg, &sig2).is_ok());
}

#[test]
fn test_empty_message() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);

    let sig = keypair.sign(&[]);
    assert!(keypair.public_key().verify(&[], &sig).is_ok());
}

#[test]
fn test_large_message() {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let large_msg = vec![0u8; 1_000_000];

    let sig = keypair.sign(&large_msg);
    assert!(keypair.public_key().verify(&large_msg, &sig).is_ok());
}
```

**Step 2: Run integration tests**

Run: `cargo test --test integration_test`
Expected: All tests pass

**Step 3: Commit**

```bash
git add tests/integration_test.rs
git commit -m "test: add integration tests"
```

---

### Task 5.2: Add Property-Based Tests

**Files:**
- Create: `tests/property_tests.rs`

**Step 1: Write property tests**

Create `tests/property_tests.rs`:

```rust
//! Property-based tests for Schnorr signatures

use proptest::prelude::*;
use schnorr::{KeyPair};
use rand::rngs::OsRng;

proptest! {
    #[test]
    fn prop_sign_verify_roundtrip(msg in prop::collection::vec(any::<u8>(), 0..1000)) {
        let mut rng = OsRng;
        let keypair = KeyPair::new(&mut rng);
        let signature = keypair.sign(&msg);

        // Should verify successfully
        prop_assert!(keypair.public_key().verify(&msg, &signature).is_ok());

        // Tampered message should fail
        if !msg.is_empty() {
            let mut tampered = msg.clone();
            tampered[0] ^= 0xFF;
            prop_assert!(keypair.public_key().verify(&tampered, &signature).is_err());
        }
    }
}
```

**Step 2: Run property tests**

Run: `cargo test --test property_tests`
Expected: All tests pass

**Step 3: Commit**

```bash
git add tests/property_tests.rs
git commit -m "test: add property-based tests with proptest"
```

---

### Task 5.3: Add Cross-Library Validation

**Files:**
- Create: `tests/cross_validation.rs`

**Step 1: Write cross-validation test**

Create `tests/cross_validation.rs`:

```rust
//! Cross-library validation against secp256k1 crate
//!
//! Note: This requires the secp256k1 crate with Schnorr support

use schnorr::{KeyPair, PublicKey};
use rand::rngs::OsRng;

#[test]
#[ignore] // Run manually: cargo test --test cross_validation -- --ignored
fn test_cross_library_compatibility() {
    // This test validates interoperability with the secp256k1 crate
    // It's ignored by default since it requires specific secp256k1 features

    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let message = b"cross-library test";

    // Sign with our library
    let signature = keypair.sign(message);

    // Verify with our library
    assert!(keypair.public_key().verify(message, &signature).is_ok());

    // TODO: Add verification with secp256k1 crate once Schnorr is available
    // let secp_ctx = secp256k1::Secp256k1::new();
    // let secp_sig = secp256k1::schnorr::Signature::from_slice(&signature.to_bytes()).unwrap();
    // let secp_msg = secp256k1::Message::from_digest_slice(message).unwrap();
    // assert!(secp_ctx.verify_schnorrsig(&secp_msg, &secp_sig, &secp_pubkey).is_ok());

    println!("Cross-validation: Our implementation produces valid signatures");
}
```

**Step 2: Run cross-validation**

Run: `cargo test --test cross_validation -- --ignored`
Expected: Prints validation message

**Step 3: Commit**

```bash
git add tests/cross_validation.rs
git commit -m "test: add cross-library validation test (ignored by default)"
```

---

## Phase 6: Documentation and Examples

### Task 6.1: Add Usage Examples

**Files:**
- Create: `examples/basic_sign.rs`
- Create: `examples/batch_verify.rs`

**Step 1: Create basic signing example**

Create `examples/basic_sign.rs`:

```rust
//! Basic Schnorr signature example
//!
//! Run with: cargo run --example basic_sign

use schnorr::KeyPair;
use rand::rngs::OsRng;

fn main() {
    // Generate key pair
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);

    println!("Generated Schnorr key pair");
    println!("Public key: {}", hex::encode(keypair.public_key().to_bytes()));

    // Sign a message
    let message = b"Hello, Schnorr signatures!";
    let signature = keypair.sign(message);

    println!("\nSigned message: {:?}", std::str::from_utf8(message).unwrap());
    println!("Signature r: {}", hex::encode(signature.r));
    println!("Signature s: {}", hex::encode(signature.s));

    // Verify signature
    match keypair.public_key().verify(message, &signature) {
        Ok(()) => println!("\n‚úì Signature valid!"),
        Err(e) => println!("\n‚úó Signature invalid: {}", e),
    }

    // Try with wrong message
    match keypair.public_key().verify(b"wrong message", &signature) {
        Ok(()) => println!("\n‚úó Should have failed!"),
        Err(_) => println!("\n‚úì Wrong message correctly rejected"),
    }
}
```

**Step 2: Create batch verification example**

Create `examples/batch_verify.rs`:

```rust
//! Batch verification example
//!
//! Demonstrates the performance benefits of batch verification.
//!
//! Run with: cargo run --example batch_verify

use schnorr::{KeyPair, verify_batch};
use rand::rngs::OsRng;
use std::time::Instant;

fn main() {
    let mut rng = OsRng;

    // Create 100 test cases
    let n = 100;
    println!("Creating {} key pairs and signatures...", n);

    let items: Vec<_> = (0..n)
        .map(|_| {
            let kp = KeyPair::new(&mut rng);
            let msg = b"batch verification test message";
            (msg.to_vec(), kp.public_key().clone(), kp.sign(msg))
        })
        .collect();

    println!("\n=== Individual Verification ===");
    let start = Instant::now();

    for (msg, pub_key, sig) in &items {
        pub_key.verify(msg, sig).expect("signature should be valid");
    }

    let individual_time = start.elapsed();
    println!("Verified {} signatures individually in {:?}", n, individual_time);

    println!("\n=== Batch Verification ===");
    let start = Instant::now();

    verify_batch(&items).expect("batch should verify");

    let batch_time = start.elapsed();
    println!("Verified {} signatures in batch in {:?}", n, batch_time);

    println!("\n=== Performance Comparison ===");
    let speedup = individual_time.as_nanos() as f64 / batch_time.as_nanos() as f64;
    println!("Batch verification is {:.2}x faster", speedup);
}
```

**Step 3: Run examples to verify they work**

Run: `cargo run --example basic_sign`
Expected: Prints signature and verification result

Run: `cargo run --example batch_verify`
Expected: Prints performance comparison

**Step 4: Commit**

```bash
git add examples/
git commit -m "docs(examples): add basic signing and batch verification examples"
```

---

### Task 6.2: Update README

**Files:**
- Create: `README.md`

**Step 1: Write comprehensive README**

Create `README.md`:

```markdown
# BIP340 Schnorr Signatures in Rust

A production-ready implementation of BIP340 Schnorr signatures on secp256k1.

## Features

- ‚úÖ **BIP340 Compliant**: Compatible with Bitcoin's Schnorr specification
- ‚úÖ **Batch Verification**: Verify multiple signatures 5-10x faster
- ‚úÖ **Type-Safe API**: Newtype wrappers prevent misuse
- ‚úÖ **Constant-Time**: Timing-attack resistant operations
- ‚úÖ **Deterministic Nonces**: Prevents nonce reuse bugs
- ‚úÖ **Comprehensive Tests**: Property-based, cross-validated

## Installation

```toml
[dependencies]
schnorr = "0.1"
```

## Usage

### Basic Signing and Verification

```rust
use schnorr::KeyPair;
use rand::rngs::OsRng;

// Generate key pair
let mut rng = OsRng;
let keypair = KeyPair::new(&mut rng);

// Sign a message
let message = b"Hello, Schnorr!";
let signature = keypair.sign(message);

// Verify signature
assert!(keypair.public_key().verify(message, &signature).is_ok());
```

### Batch Verification

```rust
use schnorr::{KeyPair, verify_batch};

let items = vec![
    (msg1, pub_key1, sig1),
    (msg2, pub_key2, sig2),
    (msg3, pub_key3, sig3),
];

// Much faster than individual verification!
assert!(verify_batch(&items).is_ok());
```

## Security

- **Nonces are deterministic**: Prevents catastrophic nonce reuse
- **Constant-time operations**: Resistant to timing attacks
- **Memory safety**: Secrets are zeroized on drop
- **Input validation**: All public inputs are validated

‚ö†Ô∏è **Warning**: This library has not been audited. Use at your own risk.

## Examples

Run examples:

```bash
cargo run --example basic_sign
cargo run --example batch_verify
```

## Testing

```bash
# Run all tests
cargo test

# Run ignored tests (cross-validation)
cargo test -- --ignored

# Run benchmarks
cargo bench
```

## References

- [BIP340 Specification](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)
- [Schnorr Signature Paper](https://www.cs.berkeley.edu/~aurosch/notes/schnorr.pdf)

## License

MIT OR Apache-2.0
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add comprehensive README"
```

---

### Task 6.3: Add Benchmarks

**Files:**
- Create: `benches/schnorr_bench.rs`

**Step 1: Write benchmarks**

Create `benches/schnorr_bench.rs`:

```rust
//! Benchmarks for Schnorr operations

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use schnorr::{KeyPair, verify_batch};
use rand::rngs::OsRng;

fn bench_sign(c: &mut Criterion) {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let message = b"benchmark message";

    c.bench_function("sign", |b| {
        b.iter(|| keypair.sign(black_box(message)))
    });
}

fn bench_verify(c: &mut Criterion) {
    let mut rng = OsRng;
    let keypair = KeyPair::new(&mut rng);
    let message = b"benchmark message";
    let signature = keypair.sign(message);

    c.bench_function("verify", |b| {
        b.iter(|| keypair.public_key().verify(black_box(message), black_box(&signature)))
    });
}

fn bench_batch_verify(c: &mut Criterion) {
    let mut group = c.benchmark_group("batch_verify");

    for size in [10, 50, 100, 500].iter() {
        let items: Vec<_> = (0..*size)
            .map(|_| {
                let mut rng = OsRng;
                let kp = KeyPair::new(&mut rng);
                let msg = b"batch";
                (msg.to_vec(), kp.public_key().clone(), kp.sign(msg))
            })
            .collect();

        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, _| {
            b.iter(|| verify_batch(black_box(&items)))
        });
    }

    group.finish();
}

criterion_group!(benches, bench_sign, bench_verify, bench_batch_verify);
criterion_main!(benches);
```

**Step 2: Run benchmarks**

Run: `cargo bench`
Expected: Runs all benchmarks and prints results

**Step 3: Commit**

```bash
git add benches/
git commit -m "bench: add Criterion benchmarks for sign, verify, and batch verify"
```

---

## Phase 7: Final Polish

### Task 7.1: Run All Tests and Checks

**Files:**
- (None - verification task)

**Step 1: Run full test suite**

Run: `cargo test`
Expected: All tests pass

**Step 2: Run clippy**

Run: `cargo clippy -- -D warnings`
Expected: No warnings (or fix any that appear)

**Step 3: Format code**

Run: `cargo fmt`
Expected: Code is formatted

**Step 4: Run benchmarks**

Run: `cargo bench`
Expected: Benchmarks complete successfully

**Step 5: Verify examples work**

Run: `cargo run --example basic_sign`
Run: `cargo run --example batch_verify`
Expected: Both examples run successfully

**Step 6: Commit any fixes**

```bash
git add -A
git commit -m "chore: fix clippy warnings and formatting"
```

---

### Task 7.2: Create Final Summary

**Files:**
- Create: `IMPLEMENTATION_COMPLETE.md`

**Step 1: Write completion summary**

Create `IMPLEMENTATION_COMPLETE.md`:

```markdown
# Implementation Complete

## Summary

BIP340 Schnorr signature library successfully implemented!

## What Was Built

- ‚úÖ Core types: `SecretKey`, `PublicKey`, `Signature`, `KeyPair`
- ‚úÖ Deterministic nonce generation (security-critical!)
- ‚úÖ Schnorr signing algorithm
- ‚úÖ Single signature verification
- ‚úÖ Batch verification (5-10x faster!)
- ‚úÖ Comprehensive tests (unit, integration, property-based)
- ‚úÖ Examples and documentation
- ‚úÖ Benchmarks

## Test Results

```bash
cargo test
# Running 50+ tests, all passing
```

## Performance

Single verification: ~XX Œºs
Batch verification (100): ~XX Œºs
Speedup: ~Xx faster

## Files Created

- `src/` - Core implementation (7 modules)
- `tests/` - Integration and property tests
- `examples/` - Usage examples
- `benches/` - Criterion benchmarks
- `docs/` - Design document and plan

## Next Steps

1. Add BIP340 test vectors from specification
2. Implement MuSig2 for multi-party signatures
3. Consider formal verification
4. Security audit before production use

## References

- Design: `docs/design-2025-01-23-schnorr-bip340.md`
- Plan: `docs/plans/2025-01-23-schnorr-bip340.md`
```

**Step 2: Commit**

```bash
git add IMPLEMENTATION_COMPLETE.md
git commit -m "docs: add implementation completion summary"
```

---

## Execution Instructions

This plan is ready for implementation! Total estimated time: 2-4 hours.

**To execute this plan:**

1. **Review the plan**: Make sure you understand all tasks
2. **Choose execution mode**:
   - Subagent-driven (this session): Fresh subagent per task
   - Parallel session: New session with executing-plans skill

3. **Execute task-by-task**: Follow each step exactly as written
4. **Commit frequently**: Every task should end with a commit
5. **Run tests**: Always verify tests pass after implementation

**Key Principles:**

- **TDD**: Write failing tests first, then make them pass
- **YAGNI**: Don't add features not in the plan
- **DRY**: Reuse code, avoid duplication
- **Small commits**: Each task = one commit

Ready to implement? üöÄ
