# Rank-1 Constraint Systems (R1CS)

Now that we understand finite fields and polynomials, let's learn how to encode computations as constraints. This is where the magic begins!

## Learning Objectives

After this chapter, you will understand:
- What R1CS is and why it's used in zero-knowledge proofs
- How to represent arithmetic expressions as matrix constraints
- The form Az ∘ Bz = Cz and what each component means
- How to convert a simple computation like `a × b = c` into R1CS
- How to verify a witness satisfies R1CS constraints

## Motivating Example: A Simple Multiplier

Let's start with a concrete problem. Suppose you want to prove you know two secret numbers `a` and `b` such that `a × b = 12`, without revealing `a` and `b` themselves.

**Example**: If `c = 12`, the prover could know:
- `a = 3, b = 4` (since 3 × 4 = 12)
- `a = 2, b = 6` (since 2 × 6 = 12)
- `a = 1, b = 12` (since 1 × 12 = 12)

But the verifier should only learn that **some valid pair exists**, not which one!

**The challenge**: How do we encode "a × b = c" as a mathematical constraint that we can verify?

## Theory Deep Dive: What is R1CS?

### The Big Picture

**R1CS (Rank-1 Constraint System)** is a way to represent computations as quadratic constraints. It's the standard input format for modern zk-SNARK systems like Groth16.

**Key idea**: Any computation can be broken down into a sequence of multiplications and additions, where each multiplication is a constraint.

### The R1CS Form

An R1CS constraint has the form:

```text
Az ∘ Bz = Cz
```

Where:
- `A, B, C` are matrices (vectors for a single constraint)
- `z` is the **witness vector** (assignment to all variables)
- `∘` denotes **element-wise multiplication**
- The equation must hold for each row (constraint)

**For a single constraint**:
- `A, B, C` are vectors (not matrices)
- `z` is the witness vector
- We check: `<A, z> · <B, z> = <C, z>` (dot products)

### The Witness Vector

The **witness** `z` contains all values in the computation:
```text
z = [1, public_outputs..., private_inputs...]
```

The `1` at the beginning is a constant (for convenience in encoding constant terms).

**Example for `a × b = c`**:
```text
z = [1, c, a, b]
   = [1, 12, 3, 4]
```

### From Arithmetic to Constraints

Let's convert `a × b = c` to R1CS step by step:

**Step 1: Identify variables**
```text
z = [1, c, a, b]
    [0, 1, 2, 3]  ← indices
```

**Step 2: Create constraint vectors**

We want: `a × b = c`

We need three vectors `A, B, C` such that:
```text
<A, z> · <B, z> = <C, z>
```

The solution:
```text
A = [0, 0, 1, 0]  ← selects 'a' (index 2)
B = [0, 0, 0, 1]  ← selects 'b' (index 3)
C = [0, 1, 0, 0]  ← selects 'c' (index 1)
```

**Step 3: Verify the constraint**

Compute each dot product:
```text
<A, z> = 0·1 + 0·c + 1·a + 0·b = a
<B, z> = 0·1 + 0·c + 0·a + 1·b = b
<C, z> = 0·1 + 1·c + 0·a + 0·b = c
```

Check the constraint:
```text
<A, z> · <B, z> = a · b
<C, z>         = c

Verify: a · b = c ✓
```

**With concrete numbers** (a=3, b=4, c=12):
```text
<A, z> = 0·1 + 0·12 + 1·3 + 0·4 = 3
<B, z> = 0·1 + 0·12 + 0·3 + 1·4 = 4
<C, z> = 0·1 + 1·12 + 0·3 + 0·4 = 12

Check: 3 · 4 = 12 ✓
```

### Why "Rank-1"?

The "Rank-1" refers to the structure of the constraint matrices. In a single constraint:
- `A` is a rank-1 matrix (can be written as outer product of vectors)
- `B` is a rank-1 matrix
- `C` is a rank-1 matrix

This structure enables the transformation to Quadratic Arithmetic Programs (QAP) in Chapter 3!

## Implementation: R1CS in Rust

Now let's see how R1CS is implemented in our codebase.

### The Constraint Structure

From `crates/r1cs/src/constraint.rs:5-43`:

```rust,ignore
/// Represents a single Rank-1 Constraint System (R1CS) constraint.
///
/// An R1CS constraint has the form: <a, x> · <b, x> = <c, x>
///
/// where:
/// - a, b, c are vectors of coefficients (sparse, represented as HashMaps)
/// - x is the assignment vector (witness)
/// - <·, ·> denotes the dot product
pub struct R1CSConstraint<F: PrimeField> {
    /// Coefficients for the A vector (left input of multiplication)
    pub a: HashMap<usize, FieldWrapper<F>>,
    /// Coefficients for the B vector (right input of multiplication)
    pub b: HashMap<usize, FieldWrapper<F>>,
    /// Coefficients for the C vector (output of multiplication)
    pub c: HashMap<usize, FieldWrapper<F>>,
}
```

**Key design choice**: We use **sparse representation** (HashMap) instead of dense vectors. This is efficient because most variables don't appear in most constraints!

### Creating a Multiplier Circuit

From `crates/circuits/src/multiplier.rs:76-88`:

```rust,ignore
pub fn to_r1cs(&self) -> Vec<R1CSConstraint<Fq>> {
    let mut constraint = R1CSConstraint::<Fq>::new();

    // A vector: selects variable a (index 2, after 1 and c)
    constraint.add_a_variable(2, FieldWrapper::<Fq>::from(1u64));

    // B vector: selects variable b (index 3)
    constraint.add_b_variable(3, FieldWrapper::<Fq>::from(1u64));

    // C vector: selects variable c (index 1, the public output)
    constraint.add_c_variable(1, FieldWrapper::<Fq>::from(1u64));

    vec![constraint]
}
```

**Note on indexing**: The witness is `[1, c, a, b]`, so:
- Index 0: constant `1`
- Index 1: public output `c`
- Index 2: private input `a`
- Index 3: private input `b`

### Verifying a Witness

The constraint satisfaction check from `crates/r1cs/src/constraint.rs:126-134`:

```rust,ignore
pub fn is_satisfied(&self, witness: &[FieldWrapper<F>]) -> bool {
    let a_value = self.evaluate_linear_combination(&self.a, witness);
    let b_value = self.evaluate_linear_combination(&self.b, witness);
    let c_value = self.evaluate_linear_combination(&self.c, witness);

    // Check: a · b = c
    let product = a_value.clone() * b_value;
    product.value == c_value.value
}
```

This computes:
```text
a_value = Σ A[i] · witness[i]
b_value = Σ B[i] · witness[i]
c_value = Σ C[i] · witness[i]

Check: a_value · b_value = c_value
```

### Generating a Witness

From `crates/circuits/src/multiplier.rs:109-116`:

```rust,ignore
pub fn witness(&self) -> Vec<FieldWrapper<Fq>> {
    vec![
        FieldWrapper::<Fq>::from(1u64),   // constant 1
        FieldWrapper::<Fq>::from(self.c), // public output c
        FieldWrapper::<Fq>::from(self.a), // private input a
        FieldWrapper::<Fq>::from(self.b), // private input b
    ]
}
```

The witness ordering is crucial! Groth16 expects:
```text
[1, public_outputs..., private_inputs...]
```

## Running the Code

Let's see the R1CS in action with the multiplier demo.

### Run the Demo

```bash
cd /path/to/groth16-demo
cargo run --example multiplier_demo
```

### Expected Output

```
Groth16 Multiplier Circuit Demo
===============================

Step 1: Creating circuit
----------------------
Private inputs: a = 3, b = 4
Public output:  c = 12

✓ Computation verified: 3 × 4 = 12

Step 2: Converting to R1CS
-------------------------
Number of R1CS constraints: 1
Number of variables per constraint: 3

R1CS Constraint Structure:
A = [0, 0, 1, 0]  (selects variable 'a')
B = [0, 0, 0, 1]  (selects variable 'b')
C = [0, 1, 0, 0]  (selects variable 'c')
Verification: a · b = c

Step 3: Generating witness
--------------------------
Witness assignment: [1, c, a, b] = [1, 12, 3, 4]

Step 4: Verifying R1CS satisfaction
-----------------------------------
R1CS constraint satisfied: true
✓ R1CS verification passed

Step 5: Converting R1CS to QAP
----------------------------
...
```

### Key Observations

1. **Single constraint** for the multiplier circuit (it's very simple!)
2. **3 variables** used in the constraint (a, b, c)
3. **Witness order**: `[1, c, a, b]` (constant first, then public output, then private inputs)
4. **Satisfaction check**: Verifies `3 × 4 = 12`

## More Complex Example: Multiple Constraints

Real circuits have multiple constraints. Let's sketch how this works:

**Example**: `(x + y) × (x - y) = z`

Let's break this down:
1. `t₁ = x + y` (addition)
2. `t₂ = x - y` (addition with negative)
3. `z = t₁ × t₂` (multiplication)

**Witness**: `z = [1, z, x, y, t₁, t₂]`

**Constraints**:
```text
Constraint 1: t₁ = x + y
  A = [0, 0, 1, 1, 0, 0]  ← x + y
  B = [1, 0, 0, 0, 0, 0]  ← 1 (for no multiplication)
  C = [0, 0, 0, 0, 1, 0]  ← t₁

Constraint 2: t₂ = x - y
  A = [0, 0, 1, -1, 0, 0] ← x - y
  B = [1, 0, 0, 0, 0, 0]  ← 1
  C = [0, 0, 0, 0, 0, 1]  ← t₂

Constraint 3: z = t₁ × t₂
  A = [0, 0, 0, 0, 1, 0]  ← t₁
  B = [0, 0, 0, 0, 0, 1]  ← t₂
  C = [0, 1, 0, 0, 0, 0]  ← z
```

Each row of A, B, C matrices is one constraint!

## Connection to Groth16

R1CS is the **first step** in the Groth16 pipeline:

```text
Computation (e.g., a × b = c)
    ↓
R1CS (matrix constraints) ← You are here
    ↓
QAP (polynomial divisibility) ← Chapter 3
    ↓
Elliptic Curve Pairings ← Chapter 4
    ↓
Zero-Knowledge Proof!
```

**Key insight**: R1CS transforms computation into a form that can be efficiently verified using polynomial arithmetic (Chapter 3) and pairings (Chapter 4).

## Exercises

1. **Basic R1CS construction**:
   ```text
   Convert "x² = y" to R1CS form.
   Hint: You need x × x = y.
   ```

2. **Witness verification**:
   ```rust
   // Given the constraint: a × b = c
   // With A = [0, 0, 1, 0], B = [0, 0, 0, 1], C = [0, 1, 0, 0]
   // And witness z = [1, 20, 4, 5]
   //
   // Does this witness satisfy the constraint?
   // Verify using the is_satisfied() method.
   ```

3. **Multi-constraint circuit**:
   ```text
   Create R1CS constraints for: (x + 1) × (y + 1) = z
   Variables: x, y (private), z (public)
   You'll need intermediate variables!
   ```

4. **Challenge question**:
   ```text
   Why is the witness ordered as [1, public_outputs..., private_inputs...]
   instead of [1, private_inputs..., public_outputs...]?
   Think about what needs to be revealed to the verifier.
   ```

## Further Reading

- **R1CS Primer**: [ZK-SNARKs in a Nutshell by Micali](https://www.youtube.com/watch?v=m7WjUDLEws4)
- **Constraint Systems**: [Bellman documentation](https://github.com/zkcrypto/bellman)
- **Sparse Representations**: [Wikipedia: Sparse Matrix](https://en.wikipedia.org/wiki/Sparse_matrix)

---

**Ready to transform R1CS to polynomials? Continue to [Chapter 3: Quadratic Arithmetic Programs](./03-qap.md)**
