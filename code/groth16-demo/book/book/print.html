<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Groth16 Zero-Knowledge Proofs: From Theory to Implementation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive tutorial on Groth16 with rigorous mathematical detail and practical Rust implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Groth16 Zero-Knowledge Proofs: From Theory to Implementation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/boycrypt/website" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to this comprehensive guide on Groth16 zero-knowledge proofs!</p>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<p>After reading this chapter, you will understand:</p>
<ul>
<li>What problem zero-knowledge proofs solve</li>
<li>Why Groth16 is a widely-used zk-SNARK protocol</li>
<li>What this project teaches you</li>
<li>How to use this tutorial effectively</li>
</ul>
<h2 id="what-are-zero-knowledge-proofs"><a class="header" href="#what-are-zero-knowledge-proofs">What Are Zero-Knowledge Proofs?</a></h2>
<p>Imagine you know a secret password, but you want to prove you know it <strong>without revealing the password itself</strong>. This is the essence of zero-knowledge proofs.</p>
<p><strong>Formal definition</strong>: A zero-knowledge proof is a cryptographic method where one party (the prover) can convince another party (the verifier) that a statement is true, without revealing any information beyond the truth of the statement itself.</p>
<h3 id="real-world-analogy-wheres-waldo"><a class="header" href="#real-world-analogy-wheres-waldo">Real-World Analogy: Where's Waldo?</a></h3>
<p>Think of the "Where's Waldo?" puzzle:</p>
<blockquote>
<p>You find Waldo quickly. You want to prove to your friend you found him, but you don't want to reveal his location (spoiling the fun).</p>
</blockquote>
<p><strong>Zero-knowledge solution</strong>:</p>
<ol>
<li>You (prover) find Waldo</li>
<li>You cover the page with a large piece of cardboard with a small cutout</li>
<li>You position the cutout over Waldo so only Waldo is visible</li>
<li>Your friend (verifier) sees Waldo through the hole</li>
<li>Your friend is convinced Waldo exists on the page</li>
<li>But your friend learns nothing about Waldo's location!</li>
</ol>
<p>This captures the three properties of zero-knowledge proofs:</p>
<ul>
<li><strong>Completeness</strong>: If Waldo is really there, your friend will be convinced</li>
<li><strong>Soundness</strong>: If Waldo isn't there, you can't fake the proof</li>
<li><strong>Zero-knowledge</strong>: Your friend learns only that Waldo exists, not where</li>
</ul>
<h2 id="why-groth16"><a class="header" href="#why-groth16">Why Groth16?</a></h2>
<p><strong>Groth16</strong> is a specific zero-knowledge proof protocol introduced by Jens Groth in 2016:</p>
<blockquote>
<p><strong>Reference</strong>: Groth, J. (2016). "On the Size of Pairing-based Non-Interactive Arguments" [EUROCRYPT 2016]</p>
</blockquote>
<h3 id="key-advantages"><a class="header" href="#key-advantages">Key Advantages</a></h3>
<ol>
<li><strong>Tiny proofs</strong>: Only 128 bytes (regardless of circuit complexity!)</li>
<li><strong>Fast verification</strong>: Constant-time verification with pairings</li>
<li><strong>Widely deployed</strong>: Used by Zcash, Ethereum (Tornado Cash), and more</li>
<li><strong>Battle-tested</strong>: Years of real-world use with no breaks</li>
</ol>
<h3 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h3>
<ol>
<li><strong>Trusted setup</strong>: Requires a one-time setup ceremony with "toxic waste"</li>
<li><strong>Per-circuit keys</strong>: Each circuit needs its own proving/verification keys</li>
<li><strong>Not universal</strong>: Unlike newer protocols (PLONK, Halo 2), Groth16 requires circuit-specific setup</li>
</ol>
<h2 id="what-this-project-teaches"><a class="header" href="#what-this-project-teaches">What This Project Teaches</a></h2>
<p>This project takes you from zero to understanding Groth16 at a rigorous mathematical level, with working Rust code you can run yourself.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li><strong>Rust basics</strong>: You know how to read Rust code</li>
<li><strong>High school math</strong>: You know what polynomials and modular arithmetic are</li>
<li><strong>Curiosity</strong>: You want to understand how the magic works!</li>
</ul>
<h3 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h3>
<p><strong>Part I: Foundations</strong></p>
<ul>
<li>Finite fields and modular arithmetic</li>
<li>Rank-1 Constraint Systems (R1CS)</li>
<li>Quadratic Arithmetic Programs (QAP)</li>
</ul>
<p><strong>Part II: The Protocol</strong></p>
<ul>
<li>Elliptic curves and pairings</li>
<li>Trusted setup ceremonies</li>
<li>Proof generation</li>
</ul>
<p><strong>Part III: Practice</strong></p>
<ul>
<li>Proof verification</li>
<li>Building your own circuits</li>
<li>Batch verification for performance</li>
</ul>
<h2 id="how-to-use-this-tutorial"><a class="header" href="#how-to-use-this-tutorial">How to Use This Tutorial</a></h2>
<h3 id="code-first-approach"><a class="header" href="#code-first-approach">Code-First Approach</a></h3>
<p>Each chapter follows this pattern:</p>
<ol>
<li><strong>Concrete example</strong>: See working code first</li>
<li><strong>Theory explanation</strong>: Understand why it works</li>
<li><strong>Mathematical detail</strong>: Connect to the Groth16 paper</li>
<li><strong>Practice</strong>: Run the code yourself</li>
</ol>
<h3 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h3>
<p>All code examples are runnable. From the project root:</p>
<pre><code class="language-bash"># Run the multiplier demo
cargo run --bin multiplier-demo

# Run tests
cargo test --workspace

# Build the project
cargo build --workspace
</code></pre>
<h3 id="following-along"><a class="header" href="#following-along">Following Along</a></h3>
<p>We recommend:</p>
<ol>
<li><strong>Read each chapter in order</strong> - concepts build on previous ones</li>
<li><strong>Run the code examples</strong> - see the cryptography in action</li>
<li><strong>Do the exercises</strong> - test your understanding</li>
<li><strong>Consult the paper</strong> - dive deeper when curious</li>
</ol>
<h2 id="quick-start-hello-world-of-zk-proofs"><a class="header" href="#quick-start-hello-world-of-zk-proofs">Quick Start: Hello World of ZK Proofs</a></h2>
<p>Let's start with a simple example: proving you know factors of a number without revealing them.</p>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<blockquote>
<p>Prove you know <code>a</code> and <code>b</code> such that <code>a √ó b = 12</code>, without revealing <code>a</code> or <code>b</code>.</p>
</blockquote>
<h3 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h3>
<pre><code class="language-rust ignore">use groth16_circuits::multiplier::MultiplierCircuit;
use groth16::{trusted_setup, generate_proof, verify_proof};
use ark_bn254::Fr as ScalarField;
use rand_chacha::ChaCha20Rng;
use rand::SeedableRng;

// Private witness: we know a=3, b=4
let circuit = MultiplierCircuit::new(3, 4, 12);

// Trusted setup ceremony (one-time)
let mut rng = ChaCha20Rng::from_entropy();
let (pk, vk) = trusted_setup(circuit.clone(), &amp;mut rng).unwrap();

// Generate proof
let proof = generate_proof(&amp;pk, circuit, &amp;mut rng).unwrap();

// Verify proof (only public input: 12)
let public_inputs = vec![ScalarField::from(12u64)];
let is_valid = verify_proof(&amp;vk, &amp;proof, &amp;public_inputs).unwrap();

assert!(is_valid);
// Verifier knows factors exist, but not which factors!</code></pre>
<h3 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h3>
<ol>
<li><strong>Circuit</strong>: We encoded the computation <code>a √ó b = c</code> as constraints</li>
<li><strong>Setup</strong>: We generated proving key (pk) and verification key (vk)</li>
<li><strong>Proof</strong>: We created a ~128-byte proof using our secret (a=3, b=4)</li>
<li><strong>Verification</strong>: The verifier checked the proof with only the public output (c=12)</li>
</ol>
<p>The verifier is convinced factors exist, but learns nothing about which factors!</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code class="language-text">groth16-demo/
‚îú‚îÄ‚îÄ crates/
‚îÇ   ‚îú‚îÄ‚îÄ groth16/              # Main Groth16 implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ wrapper.rs    # Educational wrapper with detailed comments
‚îÇ   ‚îú‚îÄ‚îÄ circuits/             # Example circuits
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ multiplier.rs # a √ó b = c circuit
‚îÇ   ‚îî‚îÄ‚îÄ [other crates...]
‚îú‚îÄ‚îÄ book/                     # This tutorial
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ 00-introduction.md
‚îÇ       ‚îú‚îÄ‚îÄ 01-math-background.md
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ examples/                 # Standalone demo programs
    ‚îî‚îÄ‚îÄ multiplier-demo.rs
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>In <strong>Chapter 1</strong>, we'll build the mathematical foundations needed to understand Groth16:</p>
<ul>
<li>Finite fields and modular arithmetic</li>
<li>Polynomials and interpolation</li>
<li>Group theory basics</li>
</ul>
<p>Don't worry if it seems abstract - everything connects back to practical code!</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Run the multiplier demo</strong>:</p>
<pre><code class="language-bash">cargo run --bin multiplier-demo
</code></pre>
<p>What do you see? Try modifying the circuit (different a, b, c values).</p>
</li>
<li>
<p><strong>Zero-knowledge property</strong>: What happens if you create a proof with a=2, b=6 (both multiply to 12) versus a=3, b=4? Can the verifier tell the difference?</p>
</li>
<li>
<p><strong>Explore the code</strong>: Open <code>crates/groth16/src/wrapper.rs</code> and read the <code>generate_proof</code> function. What parts make sense? What parts are confusing?</p>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><strong>Original Paper</strong>: <a href="https://eprint.iacr.org/2016/260">Groth16</a> - Sections 1-2 for motivation</li>
<li><strong>ZK-SNARKs Explained</strong>: <a href="https://vitalik.ca/general/2021/01/26/snarks.html">Vitalik's Blog</a></li>
<li><strong>ZCash Protocol</strong>: <a href="https://zips.z.cash/protocol/protocol.pdf#orchard">Zcash Orchard Specification</a></li>
</ul>
<hr />
<p><strong>Ready for the math? Continue to <a href="./01-math-background.html">Chapter 1: Mathematical Background</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathematical-background"><a class="header" href="#mathematical-background">Mathematical Background</a></h1>
<p>Before diving into Groth16, we need to build some mathematical foundations. Don't worry - we'll connect everything to practical code!</p>
<h2 id="learning-objectives-1"><a class="header" href="#learning-objectives-1">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>Finite fields and modular arithmetic</li>
<li>Polynomials and polynomial evaluation</li>
<li>Lagrange interpolation</li>
<li>Why polynomials are useful in zero-knowledge proofs</li>
</ul>
<h2 id="finite-fields"><a class="header" href="#finite-fields">Finite Fields</a></h2>
<h3 id="what-is-a-field"><a class="header" href="#what-is-a-field">What is a Field?</a></h3>
<p>A <strong>field</strong> is a mathematical structure where you can add, subtract, multiply, and divide (except by zero). Examples you know:</p>
<ul>
<li><strong>Rational numbers</strong> (‚Ñö): fractions like 3/4, -5/7</li>
<li><strong>Real numbers</strong> (‚Ñù): decimals like 3.14, ‚àö2</li>
<li><strong>Complex numbers</strong> (‚ÑÇ): a + bi</li>
</ul>
<h3 id="finite-fields-galois-fields"><a class="header" href="#finite-fields-galois-fields">Finite Fields (Galois Fields)</a></h3>
<p>In cryptography, we use <strong>finite fields</strong> - fields with a finite number of elements. We denote a field of prime order p as <strong>ùîΩ‚Çö</strong>.</p>
<p><strong>Example</strong>: ùîΩ‚Çá = {0, 1, 2, 3, 4, 5, 6} (integers modulo 7)</p>
<h3 id="modular-arithmetic"><a class="header" href="#modular-arithmetic">Modular Arithmetic</a></h3>
<p>Finite fields use <strong>modular arithmetic</strong> - arithmetic that wraps around.</p>
<pre><code class="language-rust ignore">// In ùîΩ‚Çá:
(5 + 4) % 7 = 9 % 7 = 2      // Addition wraps around
(3 √ó 6) % 7 = 18 % 7 = 4     // Multiplication wraps around</code></pre>
<p><strong>Key intuition</strong>: Think of a clock (modular arithmetic mod 12):</p>
<ul>
<li>10:00 + 5 hours = 3:00 (not 15:00!)</li>
<li>9:00 - 12 hours = 9:00 (going backwards wraps)</li>
</ul>
<h3 id="in-practice-arkworks-finite-fields"><a class="header" href="#in-practice-arkworks-finite-fields">In Practice: arkworks Finite Fields</a></h3>
<p>In our Rust code, we use <code>ark_bn254::Fr</code> - the scalar field for BN254 elliptic curve:</p>
<pre><code class="language-rust ignore">use ark_bn254::Fr as ScalarField;
use ark_ff::Field;

// Field elements
let a = ScalarField::from(5u64);
let b = ScalarField::from(4u64);

let sum = a + b;                          // Addition
let product = a * b;                      // Multiplication
let inverse = a.inverse().unwrap();       // Multiplicative inverse
let square = a.square();                  // Exponentiation (a¬≤)

// All operations are modulo the field prime (automatically!)</code></pre>
<p><strong>Run this example</strong>:</p>
<pre><code class="language-bash">cargo run --example field_operations
</code></pre>
<h2 id="polynomials"><a class="header" href="#polynomials">Polynomials</a></h2>
<h3 id="what-is-a-polynomial"><a class="header" href="#what-is-a-polynomial">What is a Polynomial?</a></h3>
<p>A <strong>polynomial</strong> is an expression of variables and coefficients:</p>
<pre><code class="language-text">P(x) = a‚ÇÄ + a‚ÇÅx + a‚ÇÇx¬≤ + a‚ÇÉx¬≥ + ... + a‚Çôx‚Åø
</code></pre>
<p>Where:</p>
<ul>
<li><code>a·µ¢</code> are coefficients (from a field)</li>
<li><code>x</code> is the variable</li>
<li><code>n</code> is the degree</li>
</ul>
<p><strong>Example</strong>: <code>P(x) = 2 + 3x + x¬≤</code> is a degree-2 polynomial</p>
<h3 id="why-polynomials"><a class="header" href="#why-polynomials">Why Polynomials?</a></h3>
<p>Polynomials are incredibly useful in zero-knowledge proofs because of this <strong>fundamental theorem</strong>:</p>
<blockquote>
<p><strong>Theorem</strong>: A degree-d polynomial is uniquely determined by d+1 points.</p>
</blockquote>
<p><strong>Implication</strong>: If two degree-d polynomials agree on d+1 points, they're identical!</p>
<p>This is the foundation of QAP (Quadratic Arithmetic Programs).</p>
<h3 id="polynomial-evaluation"><a class="header" href="#polynomial-evaluation">Polynomial Evaluation</a></h3>
<p>Evaluating a polynomial means computing its value at a specific point:</p>
<pre><code class="language-rust ignore">// Evaluate P(x) = 2 + 3x + x¬≤ at x = 5:
P(5) = 2 + 3(5) + 5¬≤ = 2 + 15 + 25 = 42</code></pre>
<p><strong>In code</strong>:</p>
<pre><code class="language-rust ignore">use ark_ff::Field;
use ark_bn254::Fr as ScalarField;

// P(x) = 2 + 3x + x¬≤
fn evaluate_polynomial(x: ScalarField) -&gt; ScalarField {
    ScalarField::from(2u64)
        + ScalarField::from(3u64) * x
        + x * x
}

let x = ScalarField::from(5u64);
let result = evaluate_polynomial(x);
// result = 42</code></pre>
<h3 id="polynomial-interpolation"><a class="header" href="#polynomial-interpolation">Polynomial Interpolation</a></h3>
<p><strong>Interpolation</strong> is the reverse of evaluation: given points, find the polynomial.</p>
<p><strong>Lagrange Interpolation</strong> finds the unique polynomial passing through given points:</p>
<pre><code class="language-text">Given: (1, 3), (2, 5), (3, 9)
Find: P(x) such that P(1)=3, P(2)=5, P(3)=9
</code></pre>
<p><strong>Formula</strong>: For points (x‚ÇÅ, y‚ÇÅ), ..., (x‚Çô, y‚Çô):</p>
<pre><code class="language-text">P(x) = Œ£ y·µ¢ ¬∑ L·µ¢(x)
</code></pre>
<p>Where <code>L·µ¢(x)</code> is the i-th Lagrange basis polynomial:</p>
<pre><code class="language-text">L·µ¢(x) = Œ† (x - x‚±º) / (x·µ¢ - x‚±º)  for all j ‚â† i
</code></pre>
<p><strong>Example</strong> (simplified):</p>
<p>Given points (1, 3), (2, 5):</p>
<pre><code class="language-text">L‚ÇÅ(x) = (x - 2) / (1 - 2) = (x - 2) / -1 = 2 - x
L‚ÇÇ(x) = (x - 1) / (2 - 1) = (x - 1) / 1 = x - 1

P(x) = 3¬∑L‚ÇÅ(x) + 5¬∑L‚ÇÇ(x)
     = 3(2 - x) + 5(x - 1)
     = 6 - 3x + 5x - 5
     = 1 + 2x

Verify: P(1) = 1 + 2(1) = 3 ‚úì
         P(2) = 1 + 2(2) = 5 ‚úì
</code></pre>
<h3 id="in-practice-using-arkworks"><a class="header" href="#in-practice-using-arkworks">In Practice: Using arkworks</a></h3>
<pre><code class="language-rust ignore">use ark_poly::{
    polynomial::univariate::DensePolynomial,
    EvaluationDomain,
    GeneralEvaluationDomain,
};
use ark_bn254::Fr as ScalarField;

// Create polynomial: P(x) = 1 + 2x
let coefficients = vec![
    ScalarField::from(1u64),  // constant term
    ScalarField::from(2u64),  // x term
];
let poly = DensePolynomial::from_coefficients_slice(&amp;coefficients);

// Evaluate at x = 5
let x = ScalarField::from(5u64);
let result = poly.evaluate(&amp;x);
// result = 1 + 2(5) = 11

// Interpolate polynomial from points
let domain = GeneralEvaluationDomain::new(8).unwrap();
// ... (see Chapter 3 for full QAP interpolation)</code></pre>
<h2 id="polynomial-division"><a class="header" href="#polynomial-division">Polynomial Division</a></h2>
<h3 id="the-division-test"><a class="header" href="#the-division-test">The Division Test</a></h3>
<p>A key insight in Groth16: <strong>A polynomial is divisible by another if and only if it evaluates to zero at all roots of the divisor</strong>.</p>
<p><strong>Example</strong>: Let <code>T(x) = (x - 1)(x - 2)(x - 3)</code> (a "target polynomial")</p>
<p>If <code>P(x) = H(x) ¬∑ T(x)</code>, then:</p>
<ul>
<li><code>P(1) = H(1) ¬∑ T(1) = H(1) ¬∑ 0 = 0</code></li>
<li><code>P(2) = H(2) ¬∑ T(2) = H(2) ¬∑ 0 = 0</code></li>
<li><code>P(3) = H(3) ¬∑ T(3) = H(3) ¬∑ 0 = 0</code></li>
</ul>
<p><strong>Converse</strong>: If <code>P(1) = P(2) = P(3) = 0</code>, then <code>P(x)</code> is divisible by <code>T(x)</code>!</p>
<p>This is the <strong>QAP satisfaction check</strong> in Groth16!</p>
<h3 id="in-practice-polynomial-division"><a class="header" href="#in-practice-polynomial-division">In Practice: Polynomial Division</a></h3>
<pre><code class="language-rust ignore">use ark_poly::polynomial::UVPolynomial;

// P(x) = x¬≥ - 6x¬≤ + 11x - 6
// T(x) = (x - 1)(x - 2)(x - 3) = x¬≥ - 6x¬≤ + 11x - 6
// H(x) = P(x) / T(x) = 1

let p = DensePolynomial::from_coefficients_slice(&amp;[
    ScalarField::from(6u64),   // -6
    ScalarField::from(11u64),  // 11x
    ScalarField::from(6u64),   // -6x¬≤
    ScalarField::from(1u64),   // x¬≥
]);

let t = DensePolynomial::from_coefficients_slice(&amp;[
    ScalarField::from(6u64),
    ScalarField::from(11u64),
    ScalarField::from(6u64),
    ScalarField::from(1u64),
]);

let h = &amp;p / &amp;t;
// h = 1 (the quotient polynomial)</code></pre>
<h2 id="connecting-to-groth16"><a class="header" href="#connecting-to-groth16">Connecting to Groth16</a></h2>
<h3 id="the-big-picture"><a class="header" href="#the-big-picture">The Big Picture</a></h3>
<ol>
<li><strong>R1CS</strong> (Chapter 2): Encodes computation as matrix constraints</li>
<li><strong>QAP</strong> (Chapter 3): Transforms R1CS to polynomial divisibility check</li>
<li><strong>Pairings</strong> (Chapter 4): Allow us to check polynomial equations in the exponent</li>
</ol>
<p><strong>Key insight</strong>: Checking if a polynomial division works is equivalent to checking if the computation is correct!</p>
<h3 id="example-multiplier-circuit"><a class="header" href="#example-multiplier-circuit">Example: Multiplier Circuit</a></h3>
<p>For <code>a √ó b = c</code>:</p>
<ol>
<li><strong>R1CS form</strong>: <code>Az ‚àò Bz = Cz</code> where <code>z = [1, a, b, c]</code></li>
<li><strong>QAP form</strong>: <code>P(x) = H(x) ¬∑ T(x)</code> where <code>P(x) = A(x) ¬∑ B(x) - C(x)</code></li>
<li><strong>Verification</strong>: Check if <code>P(x)</code> is divisible by <code>T(x)</code> using pairings</li>
</ol>
<p>We'll see this in detail in Chapters 2 and 3!</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>
<p><strong>Field arithmetic</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In ùîΩ‚Çá, compute:
// (3 + 5) √ó (2 + 4)
<span class="boring">}</span></code></pre></pre>
<p>What's the result? Check with Rust code.</p>
</li>
<li>
<p><strong>Polynomial evaluation</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// P(x) = 3 + 2x - x¬≤
// Compute P(4) in ùîΩ‚Çá
<span class="boring">}</span></code></pre></pre>
<p>Hint: Be careful with negative numbers!</p>
</li>
<li>
<p><strong>Interpolation intuition</strong>:</p>
<ul>
<li>Given 2 points, how many degree-1 polynomials pass through them?</li>
<li>Given 3 points, how many degree-2 polynomials pass through them?</li>
<li>Given 3 points, how many degree-3 polynomials pass through them?</li>
</ul>
</li>
<li>
<p><strong>Polynomial divisibility</strong>:</p>
<pre><code class="language-text">P(x) = x¬≥ - 6x¬≤ + 11x - 6
T(x) = (x - 1)(x - 2)(x - 3)
</code></pre>
<p>Is P(x) divisible by T(x)? Verify by evaluating P(x) at x=1, 2, 3.</p>
</li>
</ol>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><strong>Finite Fields</strong>: <a href="https://en.wikipedia.org/wiki/Finite_field">Wikipedia: Finite Field</a></li>
<li><strong>Polynomials</strong>: <a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:poly">Khan Academy: Polynomials</a></li>
<li><strong>Interpolation</strong>: <a href="https://brilliant.org/wiki/lagrange-interpolation/">Brilliant: Lagrange Interpolation</a></li>
</ul>
<hr />
<p><strong>Ready to encode computations? Continue to <a href="./02-r1cs.html">Chapter 2: Rank-1 Constraint Systems</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rank-1-constraint-systems-r1cs"><a class="header" href="#rank-1-constraint-systems-r1cs">Rank-1 Constraint Systems (R1CS)</a></h1>
<p>Now that we understand finite fields and polynomials, let's learn how to encode computations as constraints. This is where the magic begins!</p>
<h2 id="learning-objectives-2"><a class="header" href="#learning-objectives-2">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>What R1CS is and why it's used in zero-knowledge proofs</li>
<li>How to represent arithmetic expressions as matrix constraints</li>
<li>The form Az ‚àò Bz = Cz and what each component means</li>
<li>How to convert a simple computation like <code>a √ó b = c</code> into R1CS</li>
<li>How to verify a witness satisfies R1CS constraints</li>
</ul>
<h2 id="motivating-example-a-simple-multiplier"><a class="header" href="#motivating-example-a-simple-multiplier">Motivating Example: A Simple Multiplier</a></h2>
<p>Let's start with a concrete problem. Suppose you want to prove you know two secret numbers <code>a</code> and <code>b</code> such that <code>a √ó b = 12</code>, without revealing <code>a</code> and <code>b</code> themselves.</p>
<p><strong>Example</strong>: If <code>c = 12</code>, the prover could know:</p>
<ul>
<li><code>a = 3, b = 4</code> (since 3 √ó 4 = 12)</li>
<li><code>a = 2, b = 6</code> (since 2 √ó 6 = 12)</li>
<li><code>a = 1, b = 12</code> (since 1 √ó 12 = 12)</li>
</ul>
<p>But the verifier should only learn that <strong>some valid pair exists</strong>, not which one!</p>
<p><strong>The challenge</strong>: How do we encode "a √ó b = c" as a mathematical constraint that we can verify?</p>
<h2 id="theory-deep-dive-what-is-r1cs"><a class="header" href="#theory-deep-dive-what-is-r1cs">Theory Deep Dive: What is R1CS?</a></h2>
<h3 id="the-big-picture-1"><a class="header" href="#the-big-picture-1">The Big Picture</a></h3>
<p><strong>R1CS (Rank-1 Constraint System)</strong> is a way to represent computations as quadratic constraints. It's the standard input format for modern zk-SNARK systems like Groth16.</p>
<p><strong>Key idea</strong>: Any computation can be broken down into a sequence of multiplications and additions, where each multiplication is a constraint.</p>
<h3 id="the-r1cs-form"><a class="header" href="#the-r1cs-form">The R1CS Form</a></h3>
<p>An R1CS constraint has the form:</p>
<pre><code class="language-text">Az ‚àò Bz = Cz
</code></pre>
<p>Where:</p>
<ul>
<li><code>A, B, C</code> are matrices (vectors for a single constraint)</li>
<li><code>z</code> is the <strong>witness vector</strong> (assignment to all variables)</li>
<li><code>‚àò</code> denotes <strong>element-wise multiplication</strong></li>
<li>The equation must hold for each row (constraint)</li>
</ul>
<p><strong>For a single constraint</strong>:</p>
<ul>
<li><code>A, B, C</code> are vectors (not matrices)</li>
<li><code>z</code> is the witness vector</li>
<li>We check: <code>&lt;A, z&gt; ¬∑ &lt;B, z&gt; = &lt;C, z&gt;</code> (dot products)</li>
</ul>
<h3 id="the-witness-vector"><a class="header" href="#the-witness-vector">The Witness Vector</a></h3>
<p>The <strong>witness</strong> <code>z</code> contains all values in the computation:</p>
<pre><code class="language-text">z = [1, public_outputs..., private_inputs...]
</code></pre>
<p>The <code>1</code> at the beginning is a constant (for convenience in encoding constant terms).</p>
<p><strong>Example for <code>a √ó b = c</code></strong>:</p>
<pre><code class="language-text">z = [1, c, a, b]
   = [1, 12, 3, 4]
</code></pre>
<h3 id="from-arithmetic-to-constraints"><a class="header" href="#from-arithmetic-to-constraints">From Arithmetic to Constraints</a></h3>
<p>Let's convert <code>a √ó b = c</code> to R1CS step by step:</p>
<p><strong>Step 1: Identify variables</strong></p>
<pre><code class="language-text">z = [1, c, a, b]
    [0, 1, 2, 3]  ‚Üê indices
</code></pre>
<p><strong>Step 2: Create constraint vectors</strong></p>
<p>We want: <code>a √ó b = c</code></p>
<p>We need three vectors <code>A, B, C</code> such that:</p>
<pre><code class="language-text">&lt;A, z&gt; ¬∑ &lt;B, z&gt; = &lt;C, z&gt;
</code></pre>
<p>The solution:</p>
<pre><code class="language-text">A = [0, 0, 1, 0]  ‚Üê selects 'a' (index 2)
B = [0, 0, 0, 1]  ‚Üê selects 'b' (index 3)
C = [0, 1, 0, 0]  ‚Üê selects 'c' (index 1)
</code></pre>
<p><strong>Step 3: Verify the constraint</strong></p>
<p>Compute each dot product:</p>
<pre><code class="language-text">&lt;A, z&gt; = 0¬∑1 + 0¬∑c + 1¬∑a + 0¬∑b = a
&lt;B, z&gt; = 0¬∑1 + 0¬∑c + 0¬∑a + 1¬∑b = b
&lt;C, z&gt; = 0¬∑1 + 1¬∑c + 0¬∑a + 0¬∑b = c
</code></pre>
<p>Check the constraint:</p>
<pre><code class="language-text">&lt;A, z&gt; ¬∑ &lt;B, z&gt; = a ¬∑ b
&lt;C, z&gt;         = c

Verify: a ¬∑ b = c ‚úì
</code></pre>
<p><strong>With concrete numbers</strong> (a=3, b=4, c=12):</p>
<pre><code class="language-text">&lt;A, z&gt; = 0¬∑1 + 0¬∑12 + 1¬∑3 + 0¬∑4 = 3
&lt;B, z&gt; = 0¬∑1 + 0¬∑12 + 0¬∑3 + 1¬∑4 = 4
&lt;C, z&gt; = 0¬∑1 + 1¬∑12 + 0¬∑3 + 0¬∑4 = 12

Check: 3 ¬∑ 4 = 12 ‚úì
</code></pre>
<h3 id="why-rank-1"><a class="header" href="#why-rank-1">Why "Rank-1"?</a></h3>
<p>The "Rank-1" refers to the structure of the constraint matrices. In a single constraint:</p>
<ul>
<li><code>A</code> is a rank-1 matrix (can be written as outer product of vectors)</li>
<li><code>B</code> is a rank-1 matrix</li>
<li><code>C</code> is a rank-1 matrix</li>
</ul>
<p>This structure enables the transformation to Quadratic Arithmetic Programs (QAP) in Chapter 3!</p>
<h2 id="implementation-r1cs-in-rust"><a class="header" href="#implementation-r1cs-in-rust">Implementation: R1CS in Rust</a></h2>
<p>Now let's see how R1CS is implemented in our codebase.</p>
<h3 id="the-constraint-structure"><a class="header" href="#the-constraint-structure">The Constraint Structure</a></h3>
<p>From <code>crates/r1cs/src/constraint.rs:5-43</code>:</p>
<pre><code class="language-rust ignore">/// Represents a single Rank-1 Constraint System (R1CS) constraint.
///
/// An R1CS constraint has the form: &lt;a, x&gt; ¬∑ &lt;b, x&gt; = &lt;c, x&gt;
///
/// where:
/// - a, b, c are vectors of coefficients (sparse, represented as HashMaps)
/// - x is the assignment vector (witness)
/// - &lt;¬∑, ¬∑&gt; denotes the dot product
pub struct R1CSConstraint&lt;F: PrimeField&gt; {
    /// Coefficients for the A vector (left input of multiplication)
    pub a: HashMap&lt;usize, FieldWrapper&lt;F&gt;&gt;,
    /// Coefficients for the B vector (right input of multiplication)
    pub b: HashMap&lt;usize, FieldWrapper&lt;F&gt;&gt;,
    /// Coefficients for the C vector (output of multiplication)
    pub c: HashMap&lt;usize, FieldWrapper&lt;F&gt;&gt;,
}</code></pre>
<p><strong>Key design choice</strong>: We use <strong>sparse representation</strong> (HashMap) instead of dense vectors. This is efficient because most variables don't appear in most constraints!</p>
<h3 id="creating-a-multiplier-circuit"><a class="header" href="#creating-a-multiplier-circuit">Creating a Multiplier Circuit</a></h3>
<p>From <code>crates/circuits/src/multiplier.rs:76-88</code>:</p>
<pre><code class="language-rust ignore">pub fn to_r1cs(&amp;self) -&gt; Vec&lt;R1CSConstraint&lt;Fq&gt;&gt; {
    let mut constraint = R1CSConstraint::&lt;Fq&gt;::new();

    // A vector: selects variable a (index 2, after 1 and c)
    constraint.add_a_variable(2, FieldWrapper::&lt;Fq&gt;::from(1u64));

    // B vector: selects variable b (index 3)
    constraint.add_b_variable(3, FieldWrapper::&lt;Fq&gt;::from(1u64));

    // C vector: selects variable c (index 1, the public output)
    constraint.add_c_variable(1, FieldWrapper::&lt;Fq&gt;::from(1u64));

    vec![constraint]
}</code></pre>
<p><strong>Note on indexing</strong>: The witness is <code>[1, c, a, b]</code>, so:</p>
<ul>
<li>Index 0: constant <code>1</code></li>
<li>Index 1: public output <code>c</code></li>
<li>Index 2: private input <code>a</code></li>
<li>Index 3: private input <code>b</code></li>
</ul>
<h3 id="verifying-a-witness"><a class="header" href="#verifying-a-witness">Verifying a Witness</a></h3>
<p>The constraint satisfaction check from <code>crates/r1cs/src/constraint.rs:126-134</code>:</p>
<pre><code class="language-rust ignore">pub fn is_satisfied(&amp;self, witness: &amp;[FieldWrapper&lt;F&gt;]) -&gt; bool {
    let a_value = self.evaluate_linear_combination(&amp;self.a, witness);
    let b_value = self.evaluate_linear_combination(&amp;self.b, witness);
    let c_value = self.evaluate_linear_combination(&amp;self.c, witness);

    // Check: a ¬∑ b = c
    let product = a_value.clone() * b_value;
    product.value == c_value.value
}</code></pre>
<p>This computes:</p>
<pre><code class="language-text">a_value = Œ£ A[i] ¬∑ witness[i]
b_value = Œ£ B[i] ¬∑ witness[i]
c_value = Œ£ C[i] ¬∑ witness[i]

Check: a_value ¬∑ b_value = c_value
</code></pre>
<h3 id="generating-a-witness"><a class="header" href="#generating-a-witness">Generating a Witness</a></h3>
<p>From <code>crates/circuits/src/multiplier.rs:109-116</code>:</p>
<pre><code class="language-rust ignore">pub fn witness(&amp;self) -&gt; Vec&lt;FieldWrapper&lt;Fq&gt;&gt; {
    vec![
        FieldWrapper::&lt;Fq&gt;::from(1u64),   // constant 1
        FieldWrapper::&lt;Fq&gt;::from(self.c), // public output c
        FieldWrapper::&lt;Fq&gt;::from(self.a), // private input a
        FieldWrapper::&lt;Fq&gt;::from(self.b), // private input b
    ]
}</code></pre>
<p>The witness ordering is crucial! Groth16 expects:</p>
<pre><code class="language-text">[1, public_outputs..., private_inputs...]
</code></pre>
<h2 id="running-the-code"><a class="header" href="#running-the-code">Running the Code</a></h2>
<p>Let's see the R1CS in action with the multiplier demo.</p>
<h3 id="run-the-demo"><a class="header" href="#run-the-demo">Run the Demo</a></h3>
<pre><code class="language-bash">cd /path/to/groth16-demo
cargo run --example multiplier_demo
</code></pre>
<h3 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h3>
<pre><code>Groth16 Multiplier Circuit Demo
===============================

Step 1: Creating circuit
----------------------
Private inputs: a = 3, b = 4
Public output:  c = 12

‚úì Computation verified: 3 √ó 4 = 12

Step 2: Converting to R1CS
-------------------------
Number of R1CS constraints: 1
Number of variables per constraint: 3

R1CS Constraint Structure:
A = [0, 0, 1, 0]  (selects variable 'a')
B = [0, 0, 0, 1]  (selects variable 'b')
C = [0, 1, 0, 0]  (selects variable 'c')
Verification: a ¬∑ b = c

Step 3: Generating witness
--------------------------
Witness assignment: [1, c, a, b] = [1, 12, 3, 4]

Step 4: Verifying R1CS satisfaction
-----------------------------------
R1CS constraint satisfied: true
‚úì R1CS verification passed

Step 5: Converting R1CS to QAP
----------------------------
...
</code></pre>
<h3 id="key-observations"><a class="header" href="#key-observations">Key Observations</a></h3>
<ol>
<li><strong>Single constraint</strong> for the multiplier circuit (it's very simple!)</li>
<li><strong>3 variables</strong> used in the constraint (a, b, c)</li>
<li><strong>Witness order</strong>: <code>[1, c, a, b]</code> (constant first, then public output, then private inputs)</li>
<li><strong>Satisfaction check</strong>: Verifies <code>3 √ó 4 = 12</code></li>
</ol>
<h2 id="more-complex-example-multiple-constraints"><a class="header" href="#more-complex-example-multiple-constraints">More Complex Example: Multiple Constraints</a></h2>
<p>Real circuits have multiple constraints. Let's sketch how this works:</p>
<p><strong>Example</strong>: <code>(x + y) √ó (x - y) = z</code></p>
<p>Let's break this down:</p>
<ol>
<li><code>t‚ÇÅ = x + y</code> (addition)</li>
<li><code>t‚ÇÇ = x - y</code> (addition with negative)</li>
<li><code>z = t‚ÇÅ √ó t‚ÇÇ</code> (multiplication)</li>
</ol>
<p><strong>Witness</strong>: <code>z = [1, z, x, y, t‚ÇÅ, t‚ÇÇ]</code></p>
<p><strong>Constraints</strong>:</p>
<pre><code class="language-text">Constraint 1: t‚ÇÅ = x + y
  A = [0, 0, 1, 1, 0, 0]  ‚Üê x + y
  B = [1, 0, 0, 0, 0, 0]  ‚Üê 1 (for no multiplication)
  C = [0, 0, 0, 0, 1, 0]  ‚Üê t‚ÇÅ

Constraint 2: t‚ÇÇ = x - y
  A = [0, 0, 1, -1, 0, 0] ‚Üê x - y
  B = [1, 0, 0, 0, 0, 0]  ‚Üê 1
  C = [0, 0, 0, 0, 0, 1]  ‚Üê t‚ÇÇ

Constraint 3: z = t‚ÇÅ √ó t‚ÇÇ
  A = [0, 0, 0, 0, 1, 0]  ‚Üê t‚ÇÅ
  B = [0, 0, 0, 0, 0, 1]  ‚Üê t‚ÇÇ
  C = [0, 1, 0, 0, 0, 0]  ‚Üê z
</code></pre>
<p>Each row of A, B, C matrices is one constraint!</p>
<h2 id="connection-to-groth16"><a class="header" href="#connection-to-groth16">Connection to Groth16</a></h2>
<p>R1CS is the <strong>first step</strong> in the Groth16 pipeline:</p>
<pre><code class="language-text">Computation (e.g., a √ó b = c)
    ‚Üì
R1CS (matrix constraints) ‚Üê You are here
    ‚Üì
QAP (polynomial divisibility) ‚Üê Chapter 3
    ‚Üì
Elliptic Curve Pairings ‚Üê Chapter 4
    ‚Üì
Zero-Knowledge Proof!
</code></pre>
<p><strong>Key insight</strong>: R1CS transforms computation into a form that can be efficiently verified using polynomial arithmetic (Chapter 3) and pairings (Chapter 4).</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>
<p><strong>Basic R1CS construction</strong>:</p>
<pre><code class="language-text">Convert "x¬≤ = y" to R1CS form.
Hint: You need x √ó x = y.
</code></pre>
</li>
<li>
<p><strong>Witness verification</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Given the constraint: a √ó b = c
// With A = [0, 0, 1, 0], B = [0, 0, 0, 1], C = [0, 1, 0, 0]
// And witness z = [1, 20, 4, 5]
//
// Does this witness satisfy the constraint?
// Verify using the is_satisfied() method.
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Multi-constraint circuit</strong>:</p>
<pre><code class="language-text">Create R1CS constraints for: (x + 1) √ó (y + 1) = z
Variables: x, y (private), z (public)
You'll need intermediate variables!
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Why is the witness ordered as [1, public_outputs..., private_inputs...]
instead of [1, private_inputs..., public_outputs...]?
Think about what needs to be revealed to the verifier.
</code></pre>
</li>
</ol>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<ul>
<li><strong>R1CS Primer</strong>: <a href="https://www.youtube.com/watch?v=m7WjUDLEws4">ZK-SNARKs in a Nutshell by Micali</a></li>
<li><strong>Constraint Systems</strong>: <a href="https://github.com/zkcrypto/bellman">Bellman documentation</a></li>
<li><strong>Sparse Representations</strong>: <a href="https://en.wikipedia.org/wiki/Sparse_matrix">Wikipedia: Sparse Matrix</a></li>
</ul>
<hr />
<p><strong>Ready to transform R1CS to polynomials? Continue to <a href="./03-qap.html">Chapter 3: Quadratic Arithmetic Programs</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quadratic-arithmetic-programs-qap"><a class="header" href="#quadratic-arithmetic-programs-qap">Quadratic Arithmetic Programs (QAP)</a></h1>
<p>Now that we understand R1CS, let's transform those matrix constraints into polynomial equations. This is where the real magic happens!</p>
<h2 id="learning-objectives-3"><a class="header" href="#learning-objectives-3">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>What QAP is and why it's more powerful than R1CS</li>
<li>How to transform R1CS constraints into polynomial divisibility</li>
<li>The target polynomial and why it matters</li>
<li>Lagrange interpolation for constructing QAP polynomials</li>
<li>How polynomial divisibility proves constraint satisfaction</li>
</ul>
<h2 id="motivating-example-from-r1cs-to-qap"><a class="header" href="#motivating-example-from-r1cs-to-qap">Motivating Example: From R1CS to QAP</a></h2>
<p>Recall from Chapter 2 that our multiplier circuit has one R1CS constraint:</p>
<pre><code class="language-text">A = [0, 0, 1, 0]  ‚Üê selects 'a'
B = [0, 0, 0, 1]  ‚Üê selects 'b'
C = [0, 1, 0, 0]  ‚Üê selects 'c'
</code></pre>
<p><strong>The problem</strong>: R1CS requires checking each constraint individually. For large circuits with thousands of constraints, this is slow!</p>
<p><strong>The QAP solution</strong>: Transform the constraints into a single polynomial divisibility check:</p>
<pre><code class="language-text">P(x) = A(x) ¬∑ B(x) - C(x)
Is P(x) divisible by T(x)?
</code></pre>
<p>If yes, the witness satisfies ALL constraints at once!</p>
<h2 id="theory-deep-dive-what-is-qap"><a class="header" href="#theory-deep-dive-what-is-qap">Theory Deep Dive: What is QAP?</a></h2>
<h3 id="the-big-picture-2"><a class="header" href="#the-big-picture-2">The Big Picture</a></h3>
<p><strong>QAP (Quadratic Arithmetic Program)</strong> is a transformation that converts R1CS constraints into polynomial equations. Instead of checking n constraints separately, we check if one polynomial divides another.</p>
<p><strong>Key insight</strong>: Polynomial divisibility at specific points (1, 2, ..., n) is equivalent to satisfying n R1CS constraints!</p>
<h3 id="from-r1cs-matrices-to-polynomials"><a class="header" href="#from-r1cs-matrices-to-polynomials">From R1CS Matrices to Polynomials</a></h3>
<p>For each variable j (0 to m), we create three polynomials:</p>
<ul>
<li><strong>A‚±º(x)</strong>: interpolates the A-coefficients of variable j across all constraints</li>
<li><strong>B‚±º(x)</strong>: interpolates the B-coefficients of variable j across all constraints</li>
<li><strong>C‚±º(x)</strong>: interpolates the C-coefficients of variable j across all constraints</li>
</ul>
<p><strong>Example</strong>: Suppose we have 2 constraints and variable j appears as:</p>
<ul>
<li>Constraint 1: A‚ÇÅ‚±º = 1, B‚ÇÅ‚±º = 0, C‚ÇÅ‚±º = 2</li>
<li>Constraint 2: A‚ÇÇ‚±º = 3, B‚ÇÇ‚±º = 1, C‚ÇÇ‚±º = 0</li>
</ul>
<p>Then we construct:</p>
<pre><code class="language-text">A‚±º(x): passes through points (1, 1) and (2, 3)
B‚±º(x): passes through points (1, 0) and (2, 1)
C‚±º(x): passes through points (1, 2) and (2, 0)
</code></pre>
<h3 id="the-target-polynomial-tx"><a class="header" href="#the-target-polynomial-tx">The Target Polynomial T(x)</a></h3>
<p>The <strong>target polynomial</strong> is:</p>
<pre><code class="language-text">T(x) = (x - 1)(x - 2)...(x - n)
</code></pre>
<p>Where n is the number of constraints.</p>
<p><strong>Key property</strong>: T(x) has roots exactly at x = 1, 2, ..., n (the constraint indices).</p>
<h3 id="the-qap-satisfaction-check"><a class="header" href="#the-qap-satisfaction-check">The QAP Satisfaction Check</a></h3>
<p>Given a witness z = [z‚ÇÄ, z‚ÇÅ, ..., z‚Çò], we:</p>
<ol>
<li>Compute A(x) = Œ£‚±º z‚±º ¬∑ A‚±º(x)</li>
<li>Compute B(x) = Œ£‚±º z‚±º ¬∑ B‚±º(x)</li>
<li>Compute C(x) = Œ£‚±º z‚±º ¬∑ C‚±º(x)</li>
<li>Compute P(x) = A(x) ¬∑ B(x) - C(x)</li>
<li>Check if P(x) is divisible by T(x)</li>
</ol>
<p><strong>Why this works</strong>:</p>
<ul>
<li>P(i) = A(i) ¬∑ B(i) - C(i) for i = 1, ..., n</li>
<li>If the witness satisfies constraint i, then P(i) = 0</li>
<li>If P(i) = 0 for all i = 1, ..., n, then T(x) divides P(x)</li>
<li>Checking one polynomial division is faster than checking n constraints!</li>
</ul>
<h3 id="lagrange-interpolation"><a class="header" href="#lagrange-interpolation">Lagrange Interpolation</a></h3>
<p>To construct A‚±º(x), B‚±º(x), C‚±º(x), we use <strong>Lagrange interpolation</strong>:</p>
<p>Given points (x‚ÇÅ, y‚ÇÅ), (x‚ÇÇ, y‚ÇÇ), ..., (x‚Çô, y‚Çô), the unique polynomial passing through them is:</p>
<pre><code class="language-text">P(x) = Œ£·µ¢ y·µ¢ ¬∑ L·µ¢(x)
</code></pre>
<p>Where L·µ¢(x) is the i-th Lagrange basis polynomial:</p>
<pre><code class="language-text">L·µ¢(x) = Œ†‚±º‚â†·µ¢ (x - x‚±º) / (x·µ¢ - x‚±º)
</code></pre>
<p><strong>Example</strong>: Points (1, 2), (2, 4)</p>
<pre><code class="language-text">L‚ÇÅ(x) = (x - 2) / (1 - 2) = 2 - x
L‚ÇÇ(x) = (x - 1) / (2 - 1) = x - 1

P(x) = 2¬∑L‚ÇÅ(x) + 4¬∑L‚ÇÇ(x)
     = 2(2 - x) + 4(x - 1)
     = 4 - 2x + 4x - 4
     = 2x
</code></pre>
<p>Verify: P(1) = 2 ‚úì, P(2) = 4 ‚úì</p>
<h2 id="implementation-qap-in-rust"><a class="header" href="#implementation-qap-in-rust">Implementation: QAP in Rust</a></h2>
<p>Now let's see how QAP is implemented in our codebase.</p>
<h3 id="r1cs-to-qap-transformation"><a class="header" href="#r1cs-to-qap-transformation">R1CS to QAP Transformation</a></h3>
<p>From <code>crates/qap/src/polynomials.rs:60-129</code>:</p>
<pre><code class="language-rust ignore">/// Transforms an R1CS constraint system into a Quadratic Arithmetic Program.
///
/// For each variable j (0..m), this creates three polynomials A‚±º(x), B‚±º(x), C‚±º(x)
/// such that for any constraint i (1..n):
///   A‚±º(i) = coefficient of variable j in A vector of constraint i
pub fn r1cs_to_qap&lt;F&gt;(
    constraints: &amp;[R1CSConstraint&lt;F&gt;],
    num_variables: usize,
) -&gt; Result&lt;QapPolynomials&lt;F&gt;, QapError&gt;
where
    F: PrimeField,
{
    let n = constraints.len();
    let mut a_polys = Vec::with_capacity(num_variables);
    let mut b_polys = Vec::with_capacity(num_variables);
    let mut c_polys = Vec::with_capacity(num_variables);

    for j in 0..num_variables {
        // Collect points for variable j across all constraints
        let mut a_points = Vec::with_capacity(n);
        let mut b_points = Vec::with_capacity(n);
        let mut c_points = Vec::with_capacity(n);

        for (i, constraint) in constraints.iter().enumerate() {
            let x = F::from((i + 1) as u64); // 1-based constraint index

            let a_coeff = constraint.a.get(&amp;j)
                .cloned().unwrap_or_else(FieldWrapper::zero);
            let b_coeff = constraint.b.get(&amp;j)
                .cloned().unwrap_or_else(FieldWrapper::zero);
            let c_coeff = constraint.c.get(&amp;j)
                .cloned().unwrap_or_else(FieldWrapper::zero);

            a_points.push((x, a_coeff));
            b_points.push((x, b_coeff));
            c_points.push((x, c_coeff));
        }

        // Interpolate polynomials for this variable
        let a_poly = lagrange_interpolate(&amp;a_points)?;
        let b_poly = lagrange_interpolate(&amp;b_points)?;
        let c_poly = lagrange_interpolate(&amp;c_points)?;

        a_polys.push(a_poly);
        b_polys.push(b_poly);
        c_polys.push(c_poly);
    }

    Ok((a_polys, b_polys, c_polys))
}</code></pre>
<p><strong>Key observations</strong>:</p>
<ul>
<li>For each variable, we collect its coefficients across all constraints</li>
<li>We use 1-based indexing for constraint positions (x = 1, 2, ..., n)</li>
<li>Missing coefficients default to 0 (sparse representation)</li>
</ul>
<h3 id="lagrange-interpolation-implementation"><a class="header" href="#lagrange-interpolation-implementation">Lagrange Interpolation Implementation</a></h3>
<p>From <code>crates/qap/src/polynomials.rs:152-238</code>:</p>
<pre><code class="language-rust ignore">pub fn lagrange_interpolate&lt;F&gt;(
    points: &amp;[(F, FieldWrapper&lt;F&gt;)],
) -&gt; Result&lt;Polynomial&lt;F&gt;, QapError&gt;
where
    F: PrimeField,
{
    let n = points.len();

    // Start with zero polynomial
    let mut result_coeffs = vec![FieldWrapper::&lt;F&gt;::zero(); n];

    for i in 0..n {
        let (xi, yi) = &amp;points[i];

        // Compute Lagrange basis polynomial L·µ¢(x)
        let mut li_coeffs = vec![FieldWrapper::&lt;F&gt;::one()];
        let mut denominator = FieldWrapper::&lt;F&gt;::one();

        for (j, xj) in points.iter().enumerate() {
            if i == j { continue; }

            // Multiply by (x - xj)
            let mut new_coeffs = vec![FieldWrapper::&lt;F&gt;::zero(); li_coeffs.len() + 1];
            for (k, coeff) in li_coeffs.iter().enumerate() {
                new_coeffs[k + 1] += coeff.clone();  // x * coeff
                new_coeffs[k] -= coeff.clone() * FieldWrapper::&lt;F&gt;::from(xj.0);  // -xj * coeff
            }
            li_coeffs = new_coeffs;

            // Multiply denominator by (xi - xj)
            denominator = denominator * (FieldWrapper::&lt;F&gt;::from(*xi) - FieldWrapper::&lt;F&gt;::from(xj.0));
        }

        // Scale by yi / denominator
        let inv_denominator = FieldWrapper::&lt;F&gt;::from(denominator.value.inverse().unwrap());
        let scalar = yi.clone() * inv_denominator;

        // Add scaled L·µ¢(x) to result
        for (k, coeff) in li_coeffs.iter().enumerate() {
            if k &lt; result_coeffs.len() {
                result_coeffs[k] += coeff.clone() * scalar.clone();
            }
        }
    }

    Ok(Polynomial::new(result_coeffs))
}</code></pre>
<h3 id="polynomial-divisibility-check"><a class="header" href="#polynomial-divisibility-check">Polynomial Divisibility Check</a></h3>
<p>From <code>crates/qap/src/divisibility.rs:46-99</code>:</p>
<pre><code class="language-rust ignore">/// Checks if a witness polynomial is divisible by the target polynomial.
pub fn check_divisibility&lt;F&gt;(
    witness: &amp;[FieldWrapper&lt;F&gt;],
    a_polynomials: &amp;[Polynomial&lt;F&gt;],
    b_polynomials: &amp;[Polynomial&lt;F&gt;],
    c_polynomials: &amp;[Polynomial&lt;F&gt;],
    target: &amp;Polynomial&lt;F&gt;,
) -&gt; Result&lt;bool, QapError&gt;
where
    F: PrimeField,
{
    // Compute a(x) = Œ£‚±º witness[j] ¬∑ A‚±º(x)
    let mut a = Polynomial::&lt;F&gt;::new(vec![FieldWrapper::zero()]);
    for (j, poly) in a_polynomials.iter().enumerate() {
        let scaled = scale_polynomial(poly, &amp;witness[j]);
        a = a + scaled;
    }

    // Compute b(x) = Œ£‚±º witness[j] ¬∑ B‚±º(x)
    let mut b = Polynomial::&lt;F&gt;::new(vec![FieldWrapper::zero()]);
    for (j, poly) in b_polynomials.iter().enumerate() {
        let scaled = scale_polynomial(poly, &amp;witness[j]);
        b = b + scaled;
    }

    // Compute c(x) = Œ£‚±º witness[j] ¬∑ C‚±º(x)
    let mut c = Polynomial::&lt;F&gt;::new(vec![FieldWrapper::zero()]);
    for (j, poly) in c_polynomials.iter().enumerate() {
        let scaled = scale_polynomial(poly, &amp;witness[j]);
        c = c + scaled;
    }

    // Compute p(x) = a(x) ¬∑ b(x) - c(x)
    let ab = a.clone() * b.clone();
    let p = ab - c;

    // Check if p(x) is divisible by t(x)
    let (_quotient, remainder) = polynomial_long_division(&amp;p, target)?;

    // Witness is valid iff remainder is zero
    Ok(remainder.is_zero())
}</code></pre>
<h3 id="target-polynomial"><a class="header" href="#target-polynomial">Target Polynomial</a></h3>
<p>From <code>crates/qap/src/divisibility.rs:218-243</code>:</p>
<pre><code class="language-rust ignore">/// Constructs the target polynomial t(x) = ‚àè·µ¢‚Çå‚ÇÅ‚Åø (x - i).
pub fn target_polynomial&lt;F&gt;(num_constraints: usize) -&gt; Polynomial&lt;F&gt;
where
    F: PrimeField,
{
    if num_constraints == 0 {
        return Polynomial::&lt;F&gt;::new(vec![]);
    }

    // Start with (x - 1)
    let mut result = Polynomial::&lt;F&gt;::new(vec![
        FieldWrapper::&lt;F&gt;::zero() - FieldWrapper::&lt;F&gt;::one(),  // -1
        FieldWrapper::&lt;F&gt;::one(),                              // x
    ]);

    // Multiply by (x - i) for i = 2..num_constraints
    for i in 2..=num_constraints {
        let i_field = FieldWrapper::&lt;F&gt;::from(i as u64);
        let factor = Polynomial::&lt;F&gt;::new(vec![
            FieldWrapper::&lt;F&gt;::zero() - i_field,  // -i
            FieldWrapper::&lt;F&gt;::one(),              // x
        ]);
        result = result * factor;
    }

    result
}</code></pre>
<h2 id="running-the-code-1"><a class="header" href="#running-the-code-1">Running the Code</a></h2>
<p>Let's see QAP transformation in action.</p>
<h3 id="example-multiplier-circuit-1"><a class="header" href="#example-multiplier-circuit-1">Example: Multiplier Circuit</a></h3>
<p>For the multiplier <code>a √ó b = c</code> with witness <code>z = [1, 12, 3, 4]</code>:</p>
<pre><code class="language-text">Constraint 1: a √ó b = c
A = [0, 0, 1, 0]  (selects a)
B = [0, 0, 0, 1]  (selects b)
C = [0, 1, 0, 0]  (selects c)
</code></pre>
<p><strong>Single constraint QAP</strong>:</p>
<ul>
<li>T(x) = (x - 1) = x - 1</li>
<li>A‚ÇÄ(x) = 0, A‚ÇÅ(x) = 0, A‚ÇÇ(x) = 1, A‚ÇÉ(x) = 0</li>
<li>B‚ÇÄ(x) = 0, B‚ÇÅ(x) = 0, B‚ÇÇ(x) = 0, B‚ÇÉ(x) = 1</li>
<li>C‚ÇÄ(x) = 0, C‚ÇÅ(x) = 1, C‚ÇÇ(x) = 0, C‚ÇÉ(x) = 0</li>
</ul>
<p><strong>Check divisibility</strong>:</p>
<pre><code class="language-text">A(x) = Œ£‚±º z‚±º ¬∑ A‚±º(x) = 1¬∑0 + 12¬∑0 + 3¬∑1 + 4¬∑0 = 3
B(x) = Œ£‚±º z‚±º ¬∑ B‚±º(x) = 1¬∑0 + 12¬∑0 + 3¬∑0 + 4¬∑1 = 4
C(x) = Œ£‚±º z‚±º ¬∑ C‚±º(x) = 1¬∑0 + 12¬∑1 + 3¬∑0 + 4¬∑0 = 12

P(x) = A(x) ¬∑ B(x) - C(x) = 3¬∑4 - 12 = 0

Is 0 divisible by T(x)? Yes! (0 = 0 ¬∑ T(x))
</code></pre>
<h3 id="two-constraint-example"><a class="header" href="#two-constraint-example">Two-Constraint Example</a></h3>
<p>Let's create a more interesting example with 2 constraints:</p>
<pre><code class="language-text">Constraint 1: a √ó b = c
Constraint 2: c √ó c = d

A vectors:
  C1: [0, 0, 1, 0, 0]  (selects a)
  C2: [0, 0, 0, 1, 0]  (selects c)

B vectors:
  C1: [0, 0, 0, 1, 0]  (selects b)
  C2: [0, 0, 0, 1, 0]  (selects c)

C vectors:
  C1: [0, 1, 0, 0, 0]  (selects c)
  C2: [0, 0, 0, 0, 1]  (selects d)

Target: T(x) = (x - 1)(x - 2)
</code></pre>
<p>For witness <code>z = [1, 4, 2, 2, 16]</code>:</p>
<pre><code class="language-text">Constraint 1: 2 √ó 2 = 4 ‚úì
Constraint 2: 4 √ó 4 = 16 ‚úì
</code></pre>
<h2 id="connection-to-groth16-1"><a class="header" href="#connection-to-groth16-1">Connection to Groth16</a></h2>
<p>QAP is the <strong>bridge</strong> between R1CS and elliptic curve pairings:</p>
<pre><code class="language-text">Computation
    ‚Üì
R1CS (matrix constraints)
    ‚Üì
QAP (polynomial divisibility) ‚Üê You are here
    ‚Üì
Elliptic Curve Pairings (Chapter 4)
    ‚Üì
Zero-Knowledge Proof!
</code></pre>
<p><strong>Key insight</strong>: Polynomial equations can be "checked in the exponent" using pairings, enabling efficient verification!</p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>
<p><strong>Lagrange interpolation</strong>:</p>
<pre><code class="language-text">Given points (1, 3), (2, 5), (3, 9), find the polynomial P(x).
Verify: P(1) = 3, P(2) = 5, P(3) = 9
</code></pre>
</li>
<li>
<p><strong>QAP construction</strong>:</p>
<pre><code class="language-text">Given constraints:
C1: x √ó y = z
C2: x √ó x = w

Construct A‚ÇÇ(x) (for variable x).
Points: (1, 1), (2, 1)
</code></pre>
</li>
<li>
<p><strong>Divisibility check</strong>:</p>
<pre><code class="language-text">P(x) = x¬≤ - 3x + 2
T(x) = (x - 1)(x - 2)

Is P(x) divisible by T(x)?
Hint: Check if P(1) = 0 and P(2) = 0
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Why do we need at least 2 constraints for QAP?
What happens with only 1 constraint?
</code></pre>
</li>
</ol>
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h2>
<ul>
<li><strong>QAP Paper</strong>: <a href="https://eprint.iacr.org/2013/718">GGPR13 (Bitansky et al.)</a></li>
<li><strong>Lagrange Interpolation</strong>: <a href="https://brilliant.org/wiki/lagrange-interpolation/">Brilliant Wiki</a></li>
<li><strong>Polynomial Division</strong>: <a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:poly-div">Khan Academy: Dividing Polynomials</a></li>
</ul>
<hr />
<p><strong>Ready for elliptic curves? Continue to <a href="./04-pairings.html">Chapter 4: Elliptic Curves and Pairings</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elliptic-curves-and-pairings"><a class="header" href="#elliptic-curves-and-pairings">Elliptic Curves and Pairings</a></h1>
<p>We've transformed our computation into polynomial divisibility. Now we need a way to check this divisibility <strong>without revealing the polynomials themselves</strong>. Enter elliptic curve pairings!</p>
<h2 id="learning-objectives-4"><a class="header" href="#learning-objectives-4">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>What elliptic curves are and why they're useful in cryptography</li>
<li>Group operations on elliptic curves</li>
<li>Bilinear pairings and their magical properties</li>
<li>How pairings enable efficient ZK verification</li>
<li>The BN254 curve used in Groth16</li>
</ul>
<h2 id="motivating-example-the-pairing-check"><a class="header" href="#motivating-example-the-pairing-check">Motivating Example: The Pairing Check</a></h2>
<p>In QAP, we want to verify:</p>
<pre><code class="language-text">P(x) = H(x) ¬∑ T(x)
</code></pre>
<p><strong>Problem</strong>: If we reveal P(x) and H(x), we leak information about the witness!</p>
<p><strong>Solution with pairings</strong>: Check the equation <strong>in the exponent</strong>:</p>
<pre><code class="language-text">e(P‚ÇÅ, G‚ÇÇ) = e(H‚ÇÅ, T‚ÇÅ)
</code></pre>
<p>Where:</p>
<ul>
<li>P‚ÇÅ = P(x) ¬∑ G‚ÇÅ (P encrypted in G‚ÇÅ)</li>
<li>H‚ÇÅ = H(x) ¬∑ G‚ÇÅ (H encrypted in G‚ÇÅ)</li>
<li>T‚ÇÅ = T(x) ¬∑ G‚ÇÅ (T encrypted in G‚ÇÅ)</li>
<li>e(¬∑, ¬∑) is the bilinear pairing</li>
</ul>
<p>The verifier can check the equation without learning P(x), H(x), or the witness!</p>
<h2 id="theory-deep-dive-elliptic-curves"><a class="header" href="#theory-deep-dive-elliptic-curves">Theory Deep Dive: Elliptic Curves</a></h2>
<h3 id="what-is-an-elliptic-curve"><a class="header" href="#what-is-an-elliptic-curve">What is an Elliptic Curve?</a></h3>
<p>An <strong>elliptic curve</strong> over a finite field is the set of solutions (x, y) to:</p>
<pre><code class="language-text">y¬≤ = x¬≥ + ax + b
</code></pre>
<p>With a special "point at infinity" denoted ‚àû (the identity element).</p>
<p><strong>Example</strong>: The BN254 curve (used in Groth16):</p>
<pre><code class="language-text">y¬≤ = x¬≥ + 3
</code></pre>
<p>Over a field with ~2¬≤‚Åµ‚Å¥ elements.</p>
<h3 id="the-group-law"><a class="header" href="#the-group-law">The Group Law</a></h3>
<p>Elliptic curves form an <strong>abelian group</strong> under the "chord-and-tangent" addition:</p>
<p><strong>Addition (P + Q = R)</strong>:</p>
<ol>
<li>Draw a line through P and Q</li>
<li>Find the third intersection with the curve</li>
<li>Reflect across the x-axis</li>
</ol>
<p><strong>Doubling (P + P = 2P)</strong>:</p>
<ol>
<li>Draw the tangent line at P</li>
<li>Find the second intersection with the curve</li>
<li>Reflect across the x-axis</li>
</ol>
<p><strong>Scalar multiplication (k¬∑P)</strong>:</p>
<pre><code class="language-text">k¬∑P = P + P + ... + P (k times)
</code></pre>
<p>This can be computed efficiently using the "double-and-add" algorithm (O(log k) time).</p>
<h3 id="two-groups-g‚ÇÅ-and-g‚ÇÇ"><a class="header" href="#two-groups-g‚ÇÅ-and-g‚ÇÇ">Two Groups: G‚ÇÅ and G‚ÇÇ</a></h3>
<p>In pairing-based cryptography, we use <strong>two groups</strong>:</p>
<p><strong>G‚ÇÅ</strong>: Points on the curve over the base field ùîΩ‚Çö</p>
<ul>
<li>Smaller elements (more efficient)</li>
<li>Used for elements that need to be compared/combined</li>
</ul>
<p><strong>G‚ÇÇ</strong>: Points on the curve over an extension field ùîΩ‚Çö¬≤</p>
<ul>
<li>Larger elements (less efficient)</li>
<li>Used for pairing targets</li>
</ul>
<p>Both groups have the same order (number of elements): a large prime r.</p>
<h2 id="theory-deep-dive-bilinear-pairings"><a class="header" href="#theory-deep-dive-bilinear-pairings">Theory Deep Dive: Bilinear Pairings</a></h2>
<h3 id="what-is-a-pairing"><a class="header" href="#what-is-a-pairing">What is a Pairing?</a></h3>
<p>A <strong>bilinear pairing</strong> is a function:</p>
<pre><code class="language-text">e: G‚ÇÅ √ó G‚ÇÇ ‚Üí G‚Çú
</code></pre>
<p>Where G‚Çú is a target group (usually ùîΩ‚Çö‚Åø).</p>
<p><strong>Key properties</strong>:</p>
<ol>
<li>
<p><strong>Bilinearity</strong>:</p>
<pre><code class="language-text">e(a¬∑P, b¬∑Q) = e(P, Q)·µÉ¬∑·µá = e(a¬∑P, Q)·µá = e(P, b¬∑Q)·µÉ
</code></pre>
</li>
<li>
<p><strong>Non-degeneracy</strong>:</p>
<pre><code class="language-text">If e(P, Q) = 1 for all Q, then P = ‚àû
</code></pre>
</li>
<li>
<p><strong>Computability</strong>:</p>
<pre><code class="language-text">e(P, Q) can be computed efficiently
</code></pre>
</li>
</ol>
<h3 id="the-pairing-equation"><a class="header" href="#the-pairing-equation">The Pairing Equation</a></h3>
<p>The pairing enables us to check equations <strong>in the exponent</strong>:</p>
<p><strong>Integer equation</strong>:</p>
<pre><code class="language-text">a = b
</code></pre>
<p><strong>Pairing check</strong>:</p>
<pre><code class="language-text">e(a¬∑G‚ÇÅ, G‚ÇÇ) = e(b¬∑G‚ÇÅ, G‚ÇÇ)
</code></pre>
<p>This works because:</p>
<pre><code class="language-text">e(a¬∑G‚ÇÅ, G‚ÇÇ) = e(G‚ÇÅ, G‚ÇÇ)·µÉ
e(b¬∑G‚ÇÅ, G‚ÇÇ) = e(G‚ÇÅ, G‚ÇÇ)·µá

If a = b, then e(G‚ÇÅ, G‚ÇÇ)·µÉ = e(G‚ÇÅ, G‚ÇÇ)·µá
</code></pre>
<h3 id="product-equations"><a class="header" href="#product-equations">Product Equations</a></h3>
<p>Pairings also work for products:</p>
<p><strong>Integer equation</strong>:</p>
<pre><code class="language-text">a ¬∑ b = c ¬∑ d
</code></pre>
<p><strong>Pairing check</strong>:</p>
<pre><code class="language-text">e(a¬∑G‚ÇÅ, b¬∑G‚ÇÇ) = e(c¬∑G‚ÇÅ, d¬∑G‚ÇÇ)
</code></pre>
<p>This works because:</p>
<pre><code class="language-text">e(a¬∑G‚ÇÅ, b¬∑G‚ÇÇ) = e(G‚ÇÅ, G‚ÇÇ)·µÉ¬∑·µá
e(c¬∑G‚ÇÅ, d¬∑G‚ÇÇ) = e(G‚ÇÅ, G‚ÇÇ)·∂ú¬∑·µà
</code></pre>
<h2 id="implementation-pairings-in-rust"><a class="header" href="#implementation-pairings-in-rust">Implementation: Pairings in Rust</a></h2>
<p>Now let's see how pairings are implemented in our codebase.</p>
<h3 id="the-bn254-curve"><a class="header" href="#the-bn254-curve">The BN254 Curve</a></h3>
<p>We use the BN254 curve from the <code>arkworks</code> library:</p>
<pre><code class="language-rust ignore">use ark_bn254::{Bn254, G1Affine, G2Affine};
use ark_ec::pairing::Pairing;

// Bn254 is a pairing-friendly curve
type G1 = &lt;Bn254 as Pairing&gt;::G1;  // G‚ÇÅ group
type G2 = &lt;Bn254 as Pairing&gt;::G2;  // G‚ÇÇ group
type Gt = &lt;Bn254 as Pairing&gt;::TargetField;  // G‚Çú (target field)</code></pre>
<h3 id="computing-pairings"><a class="header" href="#computing-pairings">Computing Pairings</a></h3>
<p>From <code>crates/math/src/pairing.rs:6-17</code>:</p>
<pre><code class="language-rust ignore">use ark_bn254::Bn254;
use ark_ec::pairing::Pairing;

pub struct PairingGroup;

impl PairingGroup {
    pub fn verify_pairing_equation(
        a: &amp;&lt;Bn254 as Pairing&gt;::G1,
        b: &amp;&lt;Bn254 as Pairing&gt;::G2,
        c: &amp;&lt;Bn254 as Pairing&gt;::G1,
        d: &amp;&lt;Bn254 as Pairing&gt;::G2,
    ) -&gt; bool {
        // e(a, b) == e(c, d)
        let left = Bn254::pairing(*a, *b);
        let right = Bn254::pairing(*c, *d);
        left == right
    }
}</code></pre>
<p>This checks if a¬∑b = c¬∑d in the exponent:</p>
<pre><code class="language-text">e(a, b) = e(G‚ÇÅ, G‚ÇÇ)·µÉ¬∑·µá
e(c, d) = e(G‚ÇÅ, G‚ÇÇ)·∂ú¬∑·µà

e(a, b) == e(c, d) ‚ü∫ a¬∑b = c¬∑d
</code></pre>
<h3 id="group-operations"><a class="header" href="#group-operations">Group Operations</a></h3>
<pre><code class="language-rust ignore">use ark_bn254::{G1Projective as G1, G2Projective as G2};
use ark_ec::{AffineRepr, CurveGroup};

// Point addition
let p = G1::from(G1Affine::generator());
let q = G1::from(G1Affine::generator());
let r = p + q;  // 2¬∑G‚ÇÅ

// Scalar multiplication
let scalar = 5u64;
let s = G1::from(G1Affine::generator()) * scalar;  // 5¬∑G‚ÇÅ

// Convert between affine and projective representations
let affine_point = s.into_affine();
let projective_point = G1::from(affine_point);</code></pre>
<h3 id="the-verification-equation"><a class="header" href="#the-verification-equation">The Verification Equation</a></h3>
<p>In Groth16, the verification equation is:</p>
<pre><code class="language-text">e(A, B) = e(Œ±, Œ≤) ¬∑ e(Œ£ public·µ¢ ¬∑ IC·µ¢, Œ≥) ¬∑ e(C, Œ¥)
</code></pre>
<p>This checks that:</p>
<ol>
<li>A and B were constructed using the toxic waste (Œ±, Œ≤, Œ≥, Œ¥)</li>
<li>The witness matches the public inputs</li>
<li>The QAP division polynomial exists (H(x) is valid)</li>
</ol>
<p>We'll see this in detail in Chapter 7!</p>
<h2 id="running-the-code-2"><a class="header" href="#running-the-code-2">Running the Code</a></h2>
<h3 id="example-basic-pairing"><a class="header" href="#example-basic-pairing">Example: Basic Pairing</a></h3>
<pre><code class="language-rust ignore">use ark_bn254::{Bn254, G1Affine, G2Affine};
use ark_ec::pairing::Pairing;

// Get generators
let g1 = G1Affine::generator();
let g2 = G2Affine::generator();

// Compute e(5¬∑G‚ÇÅ, 3¬∑G‚ÇÇ)
let five_g1 = g1 * 5u64;
let three_g2 = g2 * 3u64;
let left = Bn254::pairing(five_g1, three_g2);

// Compute e(15¬∑G‚ÇÅ, G‚ÇÇ)
let fifteen_g1 = g1 * 15u64;
let right = Bn254::pairing(fifteen_g1, g2);

// Check: e(5¬∑G‚ÇÅ, 3¬∑G‚ÇÇ) = e(15¬∑G‚ÇÅ, G‚ÇÇ) because 5¬∑3 = 15
assert_eq!(left, right);</code></pre>
<h3 id="example-product-check"><a class="header" href="#example-product-check">Example: Product Check</a></h3>
<pre><code class="language-rust ignore">// Check if a¬∑b = c¬∑d
let a = 5u64;
let b = 3u64;
let c = 15u64;
let d = 1u64;

// e(a¬∑G‚ÇÅ, b¬∑G‚ÇÇ) = e(c¬∑G‚ÇÅ, d¬∑G‚ÇÇ)?
let left = Bn254::pairing(g1 * a, g2 * b);
let right = Bn254::pairing(g1 * c, g2 * d);

// 5¬∑3 = 15¬∑1, so this should be true
assert_eq!(left, right);</code></pre>
<h2 id="connection-to-groth16-2"><a class="header" href="#connection-to-groth16-2">Connection to Groth16</a></h2>
<p>Pairings are the <strong>final piece</strong> that makes Groth16 work:</p>
<pre><code class="language-text">Computation
    ‚Üì
R1CS (matrix constraints)
    ‚Üì
QAP (polynomial divisibility)
    ‚Üì
Elliptic Curve Pairings ‚Üê You are here
    ‚Üì
Zero-Knowledge Proof!
</code></pre>
<p><strong>Key insight</strong>: Pairings allow us to check polynomial equations without revealing the polynomials themselves!</p>
<h3 id="the-encryption-trick"><a class="header" href="#the-encryption-trick">The Encryption Trick</a></h3>
<p>We can "encrypt" field elements by multiplying by a generator:</p>
<pre><code class="language-text">plaintext: x
ciphertext: x¬∑G‚ÇÅ
</code></pre>
<p>The pairing allows us to check equations on ciphertexts:</p>
<pre><code class="language-text">Check: a + b = c
Pairing: e(a¬∑G‚ÇÅ, G‚ÇÇ) ¬∑ e(b¬∑G‚ÇÅ, G‚ÇÇ) = e(c¬∑G‚ÇÅ, G‚ÇÇ)

Check: a ¬∑ b = c
Pairing: e(a¬∑G‚ÇÅ, b¬∑G‚ÇÇ) = e(c¬∑G‚ÇÅ, G‚ÇÇ)
</code></pre>
<h2 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h2>
<h3 id="the-discrete-logarithm-problem"><a class="header" href="#the-discrete-logarithm-problem">The Discrete Logarithm Problem</a></h3>
<p>Given P = x¬∑G, it's computationally infeasible to find x.</p>
<p>This is the <strong>Elliptic Curve Discrete Logarithm Problem (ECDLP)</strong> and is the foundation of elliptic curve cryptography.</p>
<h3 id="pairing-friendly-curves"><a class="header" href="#pairing-friendly-curves">Pairing-Friendly Curves</a></h3>
<p>Not all elliptic curves support efficient pairings. The BN254 curve is specifically designed for:</p>
<ul>
<li>Efficient pairing computation</li>
<li>Security level of ~128 bits</li>
<li>Compatibility with the BN254 pairing</li>
</ul>
<p><strong>Warning</strong>: Curves not designed for pairings may have vulnerabilities!</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>
<p><strong>Scalar multiplication</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compute 7¬∑G‚ÇÅ using double-and-add
// Hint: 7 = 4 + 2 + 1 (binary: 111)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Pairing check</strong>:</p>
<pre><code class="language-text">Is e(3¬∑G‚ÇÅ, 4¬∑G‚ÇÇ) = e(6¬∑G‚ÇÅ, 2¬∑G‚ÇÇ)?
Why or why not?
</code></pre>
</li>
<li>
<p><strong>Verification equation</strong>:</p>
<pre><code class="language-text">Given: e(A, B) = e(Œ±, Œ≤) ¬∑ e(public¬∑IC, Œ≥) ¬∑ e(C, Œ¥)

If we know public, IC, Œ±, Œ≤, Œ≥, Œ¥,
what can we verify about A, B, C?
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Why do we need two groups (G‚ÇÅ and G‚ÇÇ)?
What would break if we only used G‚ÇÅ?
</code></pre>
</li>
</ol>
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further Reading</a></h2>
<ul>
<li><strong>Pairings for Beginners</strong>: <a href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">Vitalik Buterin's Blog</a></li>
<li><strong>BN254 Curve</strong>: <a href="https://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html">Barreto-Naehrig Curves</a></li>
<li><strong>Pairing-Based Crypto</strong>: <a href="https://crypto.stanford.edu/pbc/">The Pairing-Based Crypto Lounge</a></li>
</ul>
<hr />
<p><strong>Ready to generate the proving keys? Continue to <a href="./05-trusted-setup.html">Chapter 5: Trusted Setup</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-setup"><a class="header" href="#trusted-setup">Trusted Setup</a></h1>
<p>We have our QAP polynomials and understand pairings. Now we need to generate the cryptographic keys that will be used for proving and verifying. This process is called the <strong>trusted setup</strong>.</p>
<h2 id="learning-objectives-5"><a class="header" href="#learning-objectives-5">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>What trusted setup is and why it's necessary</li>
<li>The "toxic waste" problem and how to mitigate it</li>
<li>How proving and verification keys are generated</li>
<li>The structure of Groth16 keys</li>
<li>Powers of Tau and structured reference strings</li>
</ul>
<h2 id="motivating-example-why-we-need-setup"><a class="header" href="#motivating-example-why-we-need-setup">Motivating Example: Why We Need Setup</a></h2>
<p>Recall from Chapter 4 that we want to check:</p>
<pre><code class="language-text">P(x) = H(x) ¬∑ T(x)
</code></pre>
<p>Using pairings, we can check:</p>
<pre><code class="language-text">e(P‚ÇÅ, G‚ÇÇ) = e(H‚ÇÅ, T‚ÇÅ)
</code></pre>
<p><strong>Problem</strong>: We need to encrypt the QAP polynomials!</p>
<ul>
<li>We need A(œÑ)¬∑G‚ÇÅ, B(œÑ)¬∑G‚ÇÇ, C(œÑ)¬∑G‚ÇÅ for each polynomial</li>
<li>We need random values Œ±, Œ≤, Œ≥, Œ¥ to ensure soundness</li>
<li>We need a random œÑ to evaluate polynomials at</li>
</ul>
<p><strong>Solution</strong>: Run a trusted setup ceremony to generate these values!</p>
<h2 id="theory-deep-dive-what-is-trusted-setup"><a class="header" href="#theory-deep-dive-what-is-trusted-setup">Theory Deep Dive: What is Trusted Setup?</a></h2>
<h3 id="the-setup-ceremony"><a class="header" href="#the-setup-ceremony">The Setup Ceremony</a></h3>
<p>Trusted setup generates random secrets that are used to encrypt the QAP:</p>
<p><strong>Secrets generated</strong>:</p>
<ul>
<li><strong>Œ±</strong> (alpha): Used for proof A component</li>
<li><strong>Œ≤</strong> (beta): Used for proof B and C components</li>
<li><strong>Œ≥</strong> (gamma): Used for public input encryption</li>
<li><strong>Œ¥</strong> (delta): Used for proof C component</li>
<li><strong>œÑ</strong> (tau): Random point to evaluate polynomials at</li>
</ul>
<p><strong>Key properties</strong>:</p>
<ol>
<li>These secrets are random and unpredictable</li>
<li>They MUST be deleted after the ceremony</li>
<li>If leaked, anyone can forge proofs!</li>
</ol>
<h3 id="toxic-waste"><a class="header" href="#toxic-waste">Toxic Waste</a></h3>
<p>The secrets (Œ±, Œ≤, Œ≥, Œ¥, œÑ) are called <strong>"toxic waste"</strong> because:</p>
<ol>
<li><strong>Dangerous</strong>: If an attacker obtains them, they can forge proofs</li>
<li><strong>Must be destroyed</strong>: They should be securely deleted after the ceremony</li>
<li><strong>Unverifiable</strong>: We can't prove they were deleted (trust required!)</li>
</ol>
<h3 id="powers-of-tau"><a class="header" href="#powers-of-tau">Powers of Tau</a></h3>
<p>The <strong>Powers of Tau</strong> is a structured reference string (SRS):</p>
<pre><code class="language-text">[œÑ‚Å∞¬∑G‚ÇÅ, œÑ¬π¬∑G‚ÇÅ, œÑ¬≤¬∑G‚ÇÅ, ..., œÑ‚Åø¬∑G‚ÇÅ]
[œÑ‚Å∞¬∑G‚ÇÇ, œÑ¬π¬∑G‚ÇÇ, œÑ¬≤¬∑G‚ÇÇ, ..., œÑ‚Åø¬∑G‚ÇÇ]
</code></pre>
<p>These powers of œÑ allow us to evaluate any polynomial at œÑ:</p>
<pre><code class="language-text">P(x) = a‚ÇÄ + a‚ÇÅx + a‚ÇÇx¬≤
P(œÑ)¬∑G‚ÇÅ = a‚ÇÄ¬∑œÑ‚Å∞¬∑G‚ÇÅ + a‚ÇÅ¬∑œÑ¬π¬∑G‚ÇÅ + a‚ÇÇ¬∑œÑ¬≤¬∑G‚ÇÅ
</code></pre>
<p><strong>Key insight</strong>: We can compute P(œÑ)¬∑G‚ÇÅ without knowing œÑ!</p>
<h2 id="theory-deep-dive-key-structure"><a class="header" href="#theory-deep-dive-key-structure">Theory Deep Dive: Key Structure</a></h2>
<h3 id="proving-key-pk"><a class="header" href="#proving-key-pk">Proving Key (PK)</a></h3>
<p>The proving key contains encrypted elements needed to generate proofs:</p>
<p>From <code>crates/groth16/src/keys.rs:51-86</code>:</p>
<pre><code class="language-rust ignore">/// Proving key for Groth16
#[derive(Clone, Debug)]
pub struct ProvingKey {
    /// Œ±¬∑G‚ÇÅ (used in proof A component)
    pub alpha_g1: G1Affine,

    /// Œ≤¬∑G‚ÇÅ (used in proof A component)
    pub beta_g1: G1Affine,

    /// Œ≤¬∑G‚ÇÇ (used in verification)
    pub beta_g2: G2Affine,

    /// Œ¥¬∑G‚ÇÅ (used in proof C component)
    pub delta_g1: G1Affine,

    /// Œ¥¬∑G‚ÇÇ (used in verification)
    pub delta_g2: G2Affine,

    /// Encrypted A-polynomials: [Œ±¬∑A·µ¢(œÑ)¬∑G‚ÇÅ] for i=0..m
    pub a_query: Vec&lt;G1Affine&gt;,

    /// Encrypted B-polynomials in G1: [Œ≤¬∑B·µ¢(œÑ)¬∑G‚ÇÅ] for i=0..m
    pub b_g1_query: Vec&lt;G1Affine&gt;,

    /// Encrypted B-polynomials in G2: [Œ≤¬∑B·µ¢(œÑ)¬∑G‚ÇÇ] for i=0..m
    pub b_g2_query: Vec&lt;G2Affine&gt;,

    /// Encrypted C-polynomials: [Œ≤¬∑C·µ¢(œÑ)¬∑G‚ÇÅ] for i=0..m
    pub c_query: Vec&lt;G1Affine&gt;,

    /// Encrypted division polynomials: [H·µ¢(œÑ)¬∑G‚ÇÅ] for i=0..n-2
    pub h_query: Vec&lt;G1Affine&gt;,
}</code></pre>
<p><strong>Key components</strong>:</p>
<ul>
<li><strong>alpha_g1, beta_g1, beta_g2, delta_g1, delta_g2</strong>: Encrypted secrets</li>
<li><strong>a_query, b_g1_query, b_g2_query, c_query</strong>: Encrypted QAP polynomials</li>
<li><strong>h_query</strong>: Encrypted division polynomials (for H(x))</li>
</ul>
<h3 id="verification-key-vk"><a class="header" href="#verification-key-vk">Verification Key (VK)</a></h3>
<p>The verification key contains public elements for verification:</p>
<p>From <code>crates/groth16/src/keys.rs:166-188</code>:</p>
<pre><code class="language-rust ignore">/// Verification key for Groth16
#[derive(Clone, Debug)]
pub struct VerificationKey {
    /// Œ±¬∑G‚ÇÅ (part of verification equation)
    pub alpha_g1: G1Affine,

    /// Œ≤¬∑G‚ÇÇ (part of verification equation)
    pub beta_g2: G2Affine,

    /// Œ≥¬∑G‚ÇÇ (base for public input encryption)
    pub gamma_g2: G2Affine,

    /// Œ¥¬∑G‚ÇÇ (base for proof C encryption)
    pub delta_g2: G2Affine,

    /// Public input encryption: [Œ≤¬∑G‚ÇÅ, Œ≤¬∑U‚ÇÅ(œÑ)¬∑G‚ÇÅ + Œ±¬∑H‚ÇÅ(œÑ)¬∑G‚ÇÅ, ...]
    pub ic: Vec&lt;G1Affine&gt;,
}</code></pre>
<p><strong>Key components</strong>:</p>
<ul>
<li><strong>alpha_g1, beta_g2, gamma_g2, delta_g2</strong>: Public encrypted secrets</li>
<li><strong>ic</strong>: Input consistency vector for verifying public inputs</li>
</ul>
<h2 id="implementation-trusted-setup-in-rust"><a class="header" href="#implementation-trusted-setup-in-rust">Implementation: Trusted Setup in Rust</a></h2>
<p>Now let's see how trusted setup is implemented.</p>
<h3 id="the-setup-function"><a class="header" href="#the-setup-function">The Setup Function</a></h3>
<p>From <code>crates/groth16/src/setup.rs:69-213</code>:</p>
<pre><code class="language-rust ignore">/// Performs the trusted setup ceremony to generate proving and verification keys.
pub fn trusted_setup&lt;R&gt;(
    a_polys: &amp;[Polynomial&lt;ark_bn254::Fq&gt;],
    b_polys: &amp;[Polynomial&lt;ark_bn254::Fq&gt;],
    c_polys: &amp;[Polynomial&lt;ark_bn254::Fq&gt;],
    num_inputs: usize,
    rng: &amp;mut R,
) -&gt; Result&lt;(ProvingKey, VerificationKey), Groth16Error&gt;
where
    R: Rng,
{
    // Step 1: Generate random secrets (TOXIC WASTE)
    let alpha = Fr::rand(rng);
    let beta = Fr::rand(rng);
    let gamma = Fr::rand(rng);
    let delta = Fr::rand(rng);
    let tau = Fr::rand(rng);

    // Step 2: Compute powers of tau encrypted in G1 and G2
    let _tau_powers_g1 = compute_powers_of_tau_g1(tau, num_constraints + 2);
    let _tau_powers_g2 = compute_powers_of_tau_g2(tau, num_constraints + 2);

    // Step 3: Encrypt the secrets with generators
    let alpha_g1 = (G1Affine::generator() * alpha).into_affine();
    let beta_g1 = (G1Affine::generator() * beta).into_affine();
    let beta_g2 = (G2Affine::generator() * beta).into_affine();
    let gamma_g2 = (G2Affine::generator() * gamma).into_affine();
    let delta_g1 = (G1Affine::generator() * delta).into_affine();
    let delta_g2 = (G2Affine::generator() * delta).into_affine();

    // Step 4: Compute encrypted A-polynomials
    let mut a_query = Vec::with_capacity(num_vars);
    for poly in a_polys {
        let eval = poly.evaluate(&amp;tau_field);
        let encrypted = (G1Affine::generator() * alpha * eval).into_affine();
        a_query.push(encrypted);
    }

    // Step 5: Compute encrypted B-polynomials in G1 and G2
    let mut b_g1_query = Vec::with_capacity(num_vars);
    let mut b_g2_query = Vec::with_capacity(num_vars);
    for poly in b_polys {
        let eval = poly.evaluate(&amp;tau_field);
        b_g1_query.push((G1Affine::generator() * beta * eval).into_affine());
        b_g2_query.push((G2Affine::generator() * beta * eval).into_affine());
    }

    // Step 6: Compute encrypted C-polynomials in G1
    let mut c_query = Vec::with_capacity(num_vars);
    for poly in c_polys {
        let eval = poly.evaluate(&amp;tau_field);
        c_query.push((G1Affine::generator() * beta * eval).into_affine());
    }

    // Step 7: Compute division polynomials
    let target = target_polynomial::&lt;ark_bn254::Fq&gt;(num_constraints);
    let h_query = compute_division_polynomials_encrypted(&amp;target, num_constraints, tau_field)?;

    // Step 8: Compute IC for public inputs
    let mut ic = Vec::with_capacity(num_inputs + 1);
    ic.push((G1Affine::generator() * beta).into_affine());  // IC[0] = Œ≤¬∑G‚ÇÅ
    for a_poly in a_polys.iter().take(num_inputs + 1).skip(1) {
        let a_eval = a_poly.evaluate(&amp;tau_field).value;
        let ic_point = (G1Affine::generator() * beta * a_eval).into_affine();
        ic.push(ic_point);
    }

    // Construct keys
    let pk = ProvingKey { /* ... */ };
    let vk = VerificationKey { /* ... */ };

    Ok((pk, vk))
}</code></pre>
<h3 id="powers-of-tau-computation"><a class="header" href="#powers-of-tau-computation">Powers of Tau Computation</a></h3>
<p>From <code>crates/groth16/src/setup.rs:231-254</code>:</p>
<pre><code class="language-rust ignore">/// Computes powers of tau encrypted in G1
fn compute_powers_of_tau_g1(tau: Fr, degree: usize) -&gt; Vec&lt;G1Affine&gt; {
    let mut result = Vec::with_capacity(degree);
    let mut current = G1::from(G1Affine::generator());

    for _ in 0..degree {
        result.push(current.into_affine());
        current *= tau;  // Multiply by œÑ
    }

    result
}</code></pre>
<p>This computes: [G‚ÇÅ, œÑ¬∑G‚ÇÅ, œÑ¬≤¬∑G‚ÇÅ, ..., œÑ‚Åø¬∑G‚ÇÅ]</p>
<h3 id="division-polynomials"><a class="header" href="#division-polynomials">Division Polynomials</a></h3>
<p>From <code>crates/groth16/src/setup.rs:257-288</code>:</p>
<pre><code class="language-rust ignore">/// Computes division polynomials and encrypts them
fn compute_division_polynomials_encrypted(
    target: &amp;Polynomial&lt;ark_bn254::Fq&gt;,
    num_constraints: usize,
    tau: FieldWrapper&lt;ark_bn254::Fq&gt;,
) -&gt; Result&lt;Vec&lt;G1Affine&gt;, Groth16Error&gt; {
    let mut result = Vec::new();

    for j in 0..num_constraints.saturating_sub(2) {
        // Compute t(x) / (x - j)
        let j_field = FieldWrapper::&lt;ark_bn254::Fq&gt;::from(j as u64);
        let divisor = Polynomial::&lt;ark_bn254::Fq&gt;::new(vec![
            FieldWrapper::&lt;ark_bn254::Fq&gt;::zero() - j_field.clone(),
            FieldWrapper::&lt;ark_bn254::Fq&gt;::one(),
        ]);

        let (quotient, _remainder) = divide_polynomials(target, &amp;divisor)?;
        let h_j_at_tau = quotient.evaluate(&amp;tau);
        let encrypted = (G1Affine::generator() * h_j_at_tau).into_affine();
        result.push(encrypted);
    }

    Ok(result)
}</code></pre>
<h2 id="running-the-code-3"><a class="header" href="#running-the-code-3">Running the Code</a></h2>
<h3 id="example-multiplier-circuit-setup"><a class="header" href="#example-multiplier-circuit-setup">Example: Multiplier Circuit Setup</a></h3>
<pre><code class="language-bash">cd /path/to/groth16-demo
cargo test --trusted_setup_test
</code></pre>
<h3 id="what-gets-generated"><a class="header" href="#what-gets-generated">What Gets Generated</a></h3>
<p>For the multiplier circuit (a √ó b = c):</p>
<p><strong>Proving Key</strong>:</p>
<pre><code class="language-text">alpha_g1: Œ±¬∑G‚ÇÅ
beta_g1: Œ≤¬∑G‚ÇÅ
beta_g2: Œ≤¬∑G‚ÇÇ
delta_g1: Œ¥¬∑G‚ÇÅ
delta_g2: Œ¥¬∑G‚ÇÇ

a_query: [Œ±¬∑A‚ÇÄ(œÑ)¬∑G‚ÇÅ, Œ±¬∑A‚ÇÅ(œÑ)¬∑G‚ÇÅ, Œ±¬∑A‚ÇÇ(œÑ)¬∑G‚ÇÅ, Œ±¬∑A‚ÇÉ(œÑ)¬∑G‚ÇÅ]
b_g1_query: [Œ≤¬∑B‚ÇÄ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑B‚ÇÅ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑B‚ÇÇ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑B‚ÇÉ(œÑ)¬∑G‚ÇÅ]
b_g2_query: [Œ≤¬∑B‚ÇÄ(œÑ)¬∑G‚ÇÇ, Œ≤¬∑B‚ÇÅ(œÑ)¬∑G‚ÇÇ, Œ≤¬∑B‚ÇÇ(œÑ)¬∑G‚ÇÇ, Œ≤¬∑B‚ÇÉ(œÑ)¬∑G‚ÇÇ]
c_query: [Œ≤¬∑C‚ÇÄ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑C‚ÇÅ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑C‚ÇÇ(œÑ)¬∑G‚ÇÅ, Œ≤¬∑C‚ÇÉ(œÑ)¬∑G‚ÇÅ]

h_query: []  (no division polynomials for single constraint)
</code></pre>
<p><strong>Verification Key</strong>:</p>
<pre><code class="language-text">alpha_g1: Œ±¬∑G‚ÇÅ
beta_g2: Œ≤¬∑G‚ÇÇ
gamma_g2: Œ≥¬∑G‚ÇÇ
delta_g2: Œ¥¬∑G‚ÇÇ

ic: [Œ≤¬∑G‚ÇÅ, Œ≤¬∑A‚ÇÅ(œÑ)¬∑G‚ÇÅ]  (for constant 1 and public input c)
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="toxic-waste-destruction"><a class="header" href="#toxic-waste-destruction">Toxic Waste Destruction</a></h3>
<p>After the ceremony, the secrets (Œ±, Œ≤, Œ≥, Œ¥, œÑ) <strong>must be destroyed</strong>:</p>
<pre><code class="language-rust ignore">// Security: DO NOT do this!
let secrets = (alpha, beta, gamma, delta, tau);
println!("Toxic waste: {:?}", secrets);  // LEAK!

// Correct: Let them go out of scope and be dropped
drop(rng);  // The secrets only existed in the RNG state</code></pre>
<h3 id="multi-party-computation-mpc"><a class="header" href="#multi-party-computation-mpc">Multi-Party Computation (MPC)</a></h3>
<p>To reduce trust, we can use <strong>MPC ceremonies</strong>:</p>
<ol>
<li><strong>Participant 1</strong> generates secrets‚ÇÅ and creates SRS‚ÇÅ</li>
<li><strong>Participant 2</strong> generates secrets‚ÇÇ and updates: SRS‚ÇÇ = SRS‚ÇÅ ¬∑ secrets‚ÇÇ</li>
<li><strong>Participant N</strong> generates secrets‚Çô and updates: SRS‚Çô = SRS‚Çô‚Çã‚ÇÅ ¬∑ secrets‚Çô</li>
<li><strong>Final</strong>: The toxic waste is secrets‚ÇÅ ¬∑ secrets‚ÇÇ ¬∑ ... ¬∑ secrets‚Çô</li>
</ol>
<p><strong>Security</strong>: All N participants must collude to recover the toxic waste!</p>
<h3 id="per-circuit-setup"><a class="header" href="#per-circuit-setup">Per-Circuit Setup</a></h3>
<p>Groth16 requires a <strong>new setup for each circuit</strong>:</p>
<ul>
<li>Each circuit has its own QAP polynomials</li>
<li>The setup evaluates these specific polynomials at œÑ</li>
<li>Can't reuse keys across different circuits</li>
</ul>
<p><strong>Limitation</strong>: This is expensive! Newer protocols (PLONK, Halo 2) support universal setup.</p>
<h2 id="connection-to-groth16-3"><a class="header" href="#connection-to-groth16-3">Connection to Groth16</a></h2>
<p>Trusted setup is the <strong>preparation step</strong> before proving:</p>
<pre><code class="language-text">Computation
    ‚Üì
R1CS (matrix constraints)
    ‚Üì
QAP (polynomial divisibility)
    ‚Üì
Elliptic Curve Pairings
    ‚Üì
Trusted Setup ‚Üê You are here
    ‚Üì
Proof Generation (Chapter 6)
</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>
<p><strong>Key structure</strong>:</p>
<pre><code class="language-text">Why do we need both b_g1_query and b_g2_query?
Can we use just one?
</code></pre>
</li>
<li>
<p><strong>Toxic waste</strong>:</p>
<pre><code class="language-text">If alpha is leaked, what attacks become possible?
Hint: Look at the proof A component formula
</code></pre>
</li>
<li>
<p><strong>IC vector</strong>:</p>
<pre><code class="language-text">Why is IC[0] = Œ≤¬∑G‚ÇÅ?
What does it represent in the witness?
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Why can't we use a universal setup for all circuits?
What part of the setup is circuit-specific?
</code></pre>
</li>
</ol>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further Reading</a></h2>
<ul>
<li><strong>Zcash Ceremony</strong>: <a href="https://z.cash/blog/snark-explainer.html">The Powers of Tau Ceremony</a></li>
<li><strong>Perconia Ceremony</strong>: <a href="https://www.zfnd.org/blog/powers-of-tau/">Zcash Sapling Ceremony</a></li>
<li><strong>MPC Techniques</strong>: <a href="https://eprint.iacr.org/2017/1050">MPC for ZK-SNARKs</a></li>
</ul>
<hr />
<p><strong>Ready to generate proofs? Continue to <a href="./06-proof-generation.html">Chapter 6: Proof Generation</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-generation"><a class="header" href="#proof-generation">Proof Generation</a></h1>
<p>We have our proving key from the trusted setup. Now we can finally generate a zero-knowledge proof! This is where all the pieces come together.</p>
<h2 id="learning-objectives-6"><a class="header" href="#learning-objectives-6">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>How to generate a Groth16 proof from a witness</li>
<li>The proof structure (A, B, C components)</li>
<li>Random blinding and zero-knowledge</li>
<li>The division polynomial H(x)</li>
<li>How the proof demonstrates constraint satisfaction</li>
</ul>
<h2 id="motivating-example-proving-knowledge"><a class="header" href="#motivating-example-proving-knowledge">Motivating Example: Proving Knowledge</a></h2>
<p>Recall our multiplier circuit: a √ó b = c</p>
<p><strong>Scenario</strong>: You want to prove you know factors of 12 without revealing them.</p>
<p><strong>Goal</strong>: Generate a proof œÄ = (A, B, C) such that:</p>
<ul>
<li>The verifier can check œÄ against public input c = 12</li>
<li>The verifier learns nothing about a = 3 and b = 4</li>
<li>The proof is only 128 bytes (three elliptic curve points)</li>
</ul>
<h2 id="theory-deep-dive-the-proof-structure"><a class="header" href="#theory-deep-dive-the-proof-structure">Theory Deep Dive: The Proof Structure</a></h2>
<h3 id="the-proof-components"><a class="header" href="#the-proof-components">The Proof Components</a></h3>
<p>A Groth16 proof consists of three elliptic curve points:</p>
<pre><code class="language-text">œÄ = (A, B, C)
</code></pre>
<ul>
<li><strong>A</strong> ‚àà G‚ÇÅ: Proof component from A-polynomials</li>
<li><strong>B</strong> ‚àà G‚ÇÇ: Proof component from B-polynomials</li>
<li><strong>C</strong> ‚àà G‚ÇÅ: Proof component from C-polynomials and division polynomial</li>
</ul>
<h3 id="the-proof-equations"><a class="header" href="#the-proof-equations">The Proof Equations</a></h3>
<p>The prover generates A, B, C to satisfy:</p>
<pre><code class="language-text">A = [Œ±]‚ÇÅ + Œ£‚±º z‚±º¬∑[A‚±º(œÑ)]‚ÇÅ + r¬∑[Œ¥]‚ÇÅ
B = [Œ≤]‚ÇÇ + Œ£‚±º z‚±º¬∑[B‚±º(œÑ)]‚ÇÇ + s¬∑[Œ¥]‚ÇÇ
C = Œ£‚±º z‚±º¬∑[Œ≤¬∑A‚±º(œÑ) + Œ±¬∑B‚±º(œÑ) + C‚±º(œÑ)]‚ÇÅ + [H(œÑ)]‚ÇÅ + r¬∑s¬∑[Œ¥]‚ÇÅ - s¬∑[Œ≤]‚ÇÅ - r¬∑[Œ±]‚ÇÅ
</code></pre>
<p>Where:</p>
<ul>
<li>z‚±º are witness values</li>
<li>r, s are random blinding factors</li>
<li>[¬∑]‚ÇÅ means "encrypted in G‚ÇÅ" (¬∑¬∑G‚ÇÅ)</li>
<li>[¬∑]‚ÇÇ means "encrypted in G‚ÇÇ" (¬∑¬∑G‚ÇÇ)</li>
</ul>
<h3 id="zero-knowledge-via-blinding"><a class="header" href="#zero-knowledge-via-blinding">Zero-Knowledge via Blinding</a></h3>
<p>The random values <strong>r</strong> and <strong>s</strong> ensure zero-knowledge:</p>
<pre><code class="language-text">A = ... + r¬∑Œ¥
B = ... + s¬∑Œ¥
C = ... + r¬∑s¬∑Œ¥ - s¬∑Œ≤ - r¬∑Œ±
</code></pre>
<p><strong>Key insight</strong>: Different (r, s) values produce different-looking proofs for the same witness, preventing the verifier from learning anything about the witness.</p>
<h3 id="the-division-polynomial-hx"><a class="header" href="#the-division-polynomial-hx">The Division Polynomial H(x)</a></h3>
<p>Recall from QAP that we check:</p>
<pre><code class="language-text">P(x) = A(x) ¬∑ B(x) - C(x) = H(x) ¬∑ T(x)
</code></pre>
<p>The prover computes H(x) = P(x) / T(x) and includes H(œÑ) in the C component.</p>
<p><strong>Why this works</strong>:</p>
<ul>
<li>If the witness is valid, P(x) is divisible by T(x)</li>
<li>The prover can compute H(x) = P(x) / T(x)</li>
<li>H(œÑ)¬∑G‚ÇÅ is included in the proof</li>
<li>The verifier checks that H(x) exists (using the pairing equation)</li>
</ul>
<h2 id="implementation-proof-generation-in-rust"><a class="header" href="#implementation-proof-generation-in-rust">Implementation: Proof Generation in Rust</a></h2>
<p>Now let's see how proof generation is implemented.</p>
<h3 id="the-proof-structure"><a class="header" href="#the-proof-structure">The Proof Structure</a></h3>
<p>From <code>crates/groth16/src/prove.rs:24-36</code>:</p>
<pre><code class="language-rust ignore">/// Groth16 proof
///
/// A Groth16 proof consists of three group elements that demonstrate
/// knowledge of a valid witness without revealing it.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Proof {
    /// Proof component A in G‚ÇÅ
    pub a: G1Affine,
    /// Proof component B in G‚ÇÇ
    pub b: G2Affine,
    /// Proof component C in G‚ÇÅ
    pub c: G1Affine,
}</code></pre>
<h3 id="the-main-proof-function"><a class="header" href="#the-main-proof-function">The Main Proof Function</a></h3>
<p>From <code>crates/groth16/src/prove.rs:89-200</code>:</p>
<pre><code class="language-rust ignore">/// Generates a Groth16 zero-knowledge proof.
pub fn generate_proof&lt;R: Rng + ?Sized&gt;(
    pk: &amp;ProvingKey,
    witness: &amp;[FieldWrapper&lt;Fq&gt;],
    a_polys: &amp;[Polynomial&lt;Fq&gt;],
    b_polys: &amp;[Polynomial&lt;Fq&gt;],
    c_polys: &amp;[Polynomial&lt;Fq&gt;],
    _public_inputs: usize,
    rng: &amp;mut R,
) -&gt; Result&lt;Proof, Groth16Error&gt; {
    // Step 1: Compute A_base = Œ£‚±º witness[j]¬∑A‚±º(œÑ) (unblinded, without Œ±)
    let mut a_witness_blinded = G1::zero();
    for (j, w) in witness.iter().enumerate() {
        let w_fr = field_wrapper_to_fr(w);
        let g1_point = G1::from(pk.a_query[j]);
        a_witness_blinded += g1_point * w_fr;
    }
    // Extract Œ± contribution: Œ±¬∑Œ£ witness[j] where j=0 is the constant 1
    let alpha_sum = field_wrapper_to_fr(&amp;witness[0]);
    let a_alpha_part = G1::from(pk.alpha_g1) * alpha_sum;
    let a_base = a_witness_blinded - a_alpha_part;

    // Step 2: Compute B_base = Œ£‚±º witness[j]¬∑B‚±º(œÑ) (unblinded, without Œ≤)
    let mut b_witness_g2_blinded = G2::zero();
    for (j, w) in witness.iter().enumerate() {
        let w_fr = field_wrapper_to_fr(w);
        let bg2_point = G2::from(pk.b_g2_query[j]);
        b_witness_g2_blinded += bg2_point * w_fr;
    }
    // Extract Œ≤ contribution: Œ≤¬∑Œ£ witness[j]
    let beta_sum = alpha_sum; // Same sum
    let b_beta_part_g2 = G2::from(pk.beta_g2) * beta_sum;
    let b_base_g2 = b_witness_g2_blinded - b_beta_part_g2;

    // Step 3: Compute C_base = Œ£‚±º witness[j]¬∑C‚±º(œÑ) (already has Œ≤)
    let mut c_base = G1::zero();
    for (j, w) in witness.iter().enumerate() {
        let w_fr = field_wrapper_to_fr(w);
        let g1_point = G1::from(pk.c_query[j]);
        c_base += g1_point * w_fr;
    }

    // Step 4: Generate random blinding factors
    let r = Fr::rand(rng);
    let s = Fr::rand(rng);

    // Step 5: Compute proof component A
    // A = Œ±¬∑G‚ÇÅ + A_base + r¬∑Œ¥¬∑G‚ÇÅ
    let delta_g1 = G1::from(pk.delta_g1);
    let a_g1 = G1::from(pk.alpha_g1) + a_base + delta_g1 * r;

    // Step 6: Compute proof component B
    // B = Œ≤¬∑G‚ÇÇ + B_base + s¬∑Œ¥¬∑G‚ÇÇ
    let delta_g2 = G2::from(pk.delta_g2);
    let b_g2 = G2::from(pk.beta_g2) + b_base_g2 + delta_g2 * s;

    // Step 7: Compute proof component C
    // First compute the H polynomial
    let a_w_poly = compute_witness_polynomial(a_polys, witness);
    let b_w_poly = compute_witness_polynomial(b_polys, witness);
    let c_w_poly = compute_witness_polynomial(c_polys, witness);

    // Compute p(x) = A_w(x)¬∑B_w(x) - C_w(x)
    let product_poly = a_w_poly.clone() * b_w_poly.clone();
    let diff_poly = product_poly - c_w_poly;

    // Get target polynomial t(x)
    let target_poly = groth16_qap::target_polynomial::&lt;Fq&gt;(num_constraints);

    // Divide to get H(x)
    let (h_poly, _remainder) = divide_polynomials(&amp;diff_poly, &amp;target_poly)?;

    // Compute H(œÑ)¬∑G‚ÇÅ
    let h_at_tau = h_poly.evaluate(&amp;tau_field);
    let h_fr = fq_to_fr(&amp;h_at_tau.value);

    // Lookup in h_query
    let mut h_encrypted = G1::zero();
    for (j, coeff) in h_poly.coeffs.iter().enumerate() {
        if j &lt; pk.h_query.len() {
            let h_point = G1::from(pk.h_query[j]);
            h_encrypted += h_point * fq_to_fr(&amp;coeff.value);
        }
    }

    // C = Œ≤¬∑A_base¬∑s + Œ±¬∑B_base¬∑r + C_base + H(œÑ) + r¬∑s¬∑Œ¥
    let c_g1 = c_base
        + a_base.clone() * s
        + b_base_g1.clone() * r
        + h_encrypted
        + delta_g1 * (r * s)
        - G1::from(pk.beta_g1) * s
        - G1::from(pk.alpha_g1) * r;

    Ok(Proof {
        a: a_g1.into_affine(),
        b: b_g2.into_affine(),
        c: c_g1.into_affine(),
    })
}</code></pre>
<h3 id="computing-the-witness-polynomial"><a class="header" href="#computing-the-witness-polynomial">Computing the Witness Polynomial</a></h3>
<pre><code class="language-rust ignore">/// Computes the witness polynomial: W(x) = Œ£‚±º witness[j]¬∑P‚±º(x)
fn compute_witness_polynomial&lt;F&gt;(
    polynomials: &amp;[Polynomial&lt;F&gt;],
    witness: &amp;[FieldWrapper&lt;F&gt;],
) -&gt; Polynomial&lt;F&gt;
where
    F: PrimeField,
{
    let mut result = Polynomial::&lt;F&gt;::new(vec![FieldWrapper::zero()]);

    for (j, poly) in polynomials.iter().enumerate() {
        let scaled = scale_polynomial(poly, &amp;witness[j]);
        result = result + scaled;
    }

    result
}</code></pre>
<h2 id="running-the-code-4"><a class="header" href="#running-the-code-4">Running the Code</a></h2>
<h3 id="example-generating-a-proof"><a class="header" href="#example-generating-a-proof">Example: Generating a Proof</a></h3>
<pre><code class="language-rust ignore">use groth16_groth16::{trusted_setup, generate_proof};
use groth16_circuits::multiplier::MultiplierCircuit;
use groth16_qap::r1cs_to_qap;

// Create circuit
let circuit = MultiplierCircuit::new(3, 4, 12);
let witness = circuit.witness();  // [1, 12, 3, 4]

// Convert to R1CS and QAP
let constraints = circuit.to_r1cs();
let (a_polys, b_polys, c_polys) = r1cs_to_qap(&amp;constraints, 4)?;

// Trusted setup
let (pk, vk) = trusted_setup(&amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng)?;

// Generate proof
let proof = generate_proof(&amp;pk, &amp;witness, &amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng)?;

println!("Proof generated:");
println!("  A: {:?}", proof.a);
println!("  B: {:?}", proof.b);
println!("  C: {:?}", proof.c);</code></pre>
<h3 id="what-the-proof-contains"><a class="header" href="#what-the-proof-contains">What the Proof Contains</a></h3>
<p>For the multiplier circuit (a=3, b=4, c=12):</p>
<pre><code class="language-text">A = Œ±¬∑G‚ÇÅ + 3¬∑A‚ÇÇ(œÑ)¬∑G‚ÇÅ + r¬∑Œ¥¬∑G‚ÇÅ
  = Œ±¬∑G‚ÇÅ + 3¬∑G‚ÇÅ + r¬∑Œ¥¬∑G‚ÇÅ  (since A‚ÇÇ(x) = 1)

B = Œ≤¬∑G‚ÇÇ + 4¬∑B‚ÇÉ(œÑ)¬∑G‚ÇÇ + s¬∑Œ¥¬∑G‚ÇÇ
  = Œ≤¬∑G‚ÇÇ + 4¬∑G‚ÇÇ + s¬∑Œ¥¬∑G‚ÇÇ  (since B‚ÇÉ(x) = 1)

C = ... (complex formula involving H(œÑ))
</code></pre>
<p>The verifier only sees the elliptic curve points, not the witness values!</p>
<h2 id="security-properties-1"><a class="header" href="#security-properties-1">Security Properties</a></h2>
<h3 id="zero-knowledge"><a class="header" href="#zero-knowledge">Zero-Knowledge</a></h3>
<p>The random values r and s ensure that:</p>
<ul>
<li>Different proofs for the same witness look different</li>
<li>The verifier cannot deduce the witness from the proof</li>
<li>No information about a and b is leaked</li>
</ul>
<h3 id="soundness"><a class="header" href="#soundness">Soundness</a></h3>
<p>A malicious prover cannot create a valid proof for an invalid witness because:</p>
<ul>
<li>The pairing equation (Chapter 7) would fail</li>
<li>They would need to know Œ±, Œ≤, Œ≥, Œ¥ (toxic waste)</li>
<li>The division polynomial H(x) wouldn't exist for invalid witnesses</li>
</ul>
<h3 id="proof-size"><a class="header" href="#proof-size">Proof Size</a></h3>
<p>A Groth16 proof is only <strong>128 bytes</strong>:</p>
<ul>
<li>A ‚àà G‚ÇÅ: 32 bytes (compressed)</li>
<li>B ‚àà G‚ÇÇ: 64 bytes (compressed)</li>
<li>C ‚àà G‚ÇÅ: 32 bytes (compressed)</li>
</ul>
<p>This is constant regardless of circuit complexity!</p>
<h2 id="connection-to-groth16-4"><a class="header" href="#connection-to-groth16-4">Connection to Groth16</a></h2>
<p>Proof generation is the <strong>proving phase</strong> of Groth16:</p>
<pre><code class="language-text">Computation
    ‚Üì
R1CS (matrix constraints)
    ‚Üì
QAP (polynomial divisibility)
    ‚Üì
Elliptic Curve Pairings
    ‚Üì
Trusted Setup
    ‚Üì
Proof Generation ‚Üê You are here
    ‚Üì
Proof Verification (Chapter 7)
</code></pre>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>
<p><strong>Blinding factors</strong>:</p>
<pre><code class="language-text">What happens if r = 0 and s = 0?
Is the proof still zero-knowledge?
</code></pre>
</li>
<li>
<p><strong>Division polynomial</strong>:</p>
<pre><code class="language-text">For the multiplier circuit, what is H(x)?
Hint: P(x) = 3¬∑4 - 12 = 0, so H(x) = 0 / T(x) = 0
</code></pre>
</li>
<li>
<p><strong>Proof size</strong>:</p>
<pre><code class="language-text">Why is the proof size constant?
Why doesn't it grow with circuit complexity?
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Can a prover generate a proof without knowing the witness?
What would prevent this?
</code></pre>
</li>
</ol>
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further Reading</a></h2>
<ul>
<li><strong>Groth16 Paper</strong>: <a href="https://eprint.iacr.org/2016/260">On the Size of Pairing-based Non-Interactive Arguments</a></li>
<li><strong>Zero-Knowledge Proofs</strong>: <a href="https://zkp.science/">ZK-SNARKs Explained</a></li>
<li><strong>Proof Systems</strong>: <a href="https://eprint.iacr.org/2019/953">Proof Systems Survey</a></li>
</ul>
<hr />
<p><strong>Ready to verify proofs? Continue to <a href="./07-proof-verification.html">Chapter 7: Proof Verification</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-verification"><a class="header" href="#proof-verification">Proof Verification</a></h1>
<p>We've generated our proof. Now the verifier needs to check that it's valid without learning anything about the witness. This is where the pairing equation comes in!</p>
<h2 id="learning-objectives-7"><a class="header" href="#learning-objectives-7">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>The Groth16 verification equation</li>
<li>How pairings enable efficient verification</li>
<li>Constant-time verification regardless of circuit size</li>
<li>Batch verification for efficiency</li>
<li>Security properties of verification</li>
</ul>
<h2 id="motivating-example-the-verification-check"><a class="header" href="#motivating-example-the-verification-check">Motivating Example: The Verification Check</a></h2>
<p>The prover sends:</p>
<ul>
<li>Proof œÄ = (A, B, C)</li>
<li>Public inputs (e.g., c = 12 for the multiplier)</li>
</ul>
<p>The verifier needs to check:</p>
<ol>
<li>The proof was generated correctly</li>
<li>The public inputs match the witness</li>
<li>The witness satisfies all constraints</li>
<li>No information about the witness is leaked</li>
</ol>
<p><strong>All in constant time!</strong></p>
<h2 id="theory-deep-dive-the-verification-equation"><a class="header" href="#theory-deep-dive-the-verification-equation">Theory Deep Dive: The Verification Equation</a></h2>
<h3 id="the-pairing-equation-1"><a class="header" href="#the-pairing-equation-1">The Pairing Equation</a></h3>
<p>A Groth16 proof is valid if and only if:</p>
<pre><code class="language-text">e(A, B) = e(Œ±, Œ≤) ¬∑ e(Œ£ public·µ¢¬∑IC·µ¢, Œ≥) ¬∑ e(C, Œ¥)
</code></pre>
<p>Where:</p>
<ul>
<li><strong>e(¬∑, ¬∑)</strong> is the bilinear pairing</li>
<li><strong>A, B, C</strong> are the proof components</li>
<li><strong>Œ±, Œ≤, Œ≥, Œ¥</strong> are from the verification key</li>
<li><strong>IC·µ¢</strong> are the input consistency elements</li>
<li><strong>public·µ¢</strong> are the public inputs</li>
</ul>
<h3 id="expanding-the-equation"><a class="header" href="#expanding-the-equation">Expanding the Equation</a></h3>
<p>Let's expand what each component means:</p>
<p><strong>Left side</strong>:</p>
<pre><code class="language-text">e(A, B) = e(Œ±¬∑G‚ÇÅ + A_witness + r¬∑Œ¥¬∑G‚ÇÅ, Œ≤¬∑G‚ÇÇ + B_witness + s¬∑Œ¥¬∑G‚ÇÇ)
</code></pre>
<p><strong>Right side</strong>:</p>
<pre><code class="language-text">e(Œ±, Œ≤) ¬∑ e(Œ£ public¬∑IC, Œ≥) ¬∑ e(C, Œ¥)
</code></pre>
<p>When the proof is correctly generated, these two sides are equal!</p>
<h3 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h3>
<p>The verification equation checks three things:</p>
<ol>
<li><strong>Proof structure</strong>: A and B use the correct secrets (Œ±, Œ≤, Œ¥)</li>
<li><strong>Public input consistency</strong>: The witness matches the claimed public inputs</li>
<li><strong>QAP satisfaction</strong>: The division polynomial H(x) exists</li>
</ol>
<p>If any of these fail, the pairing equation won't hold!</p>
<h3 id="the-public-input-term"><a class="header" href="#the-public-input-term">The Public Input Term</a></h3>
<p>The term <strong>e(Œ£ public·µ¢¬∑IC·µ¢, Œ≥)</strong> ensures public input consistency:</p>
<pre><code class="language-text">IC[0] = Œ≤¬∑G‚ÇÅ (for the constant 1)
IC[i] = Œ≤¬∑A·µ¢(œÑ)¬∑G‚ÇÅ for i = 1..num_inputs

Œ£ public·µ¢¬∑IC·µ¢ = public‚ÇÄ¬∑IC[0] + public‚ÇÅ¬∑IC[1] + ...
              = 1¬∑Œ≤¬∑G‚ÇÅ + c¬∑Œ≤¬∑A‚ÇÅ(œÑ)¬∑G‚ÇÅ
              = Œ≤¬∑(1 + c¬∑A‚ÇÅ(œÑ))¬∑G‚ÇÅ
</code></pre>
<p>This ensures the witness used the correct public inputs!</p>
<h2 id="implementation-verification-in-rust"><a class="header" href="#implementation-verification-in-rust">Implementation: Verification in Rust</a></h2>
<p>Now let's see how verification is implemented.</p>
<h3 id="the-main-verification-function"><a class="header" href="#the-main-verification-function">The Main Verification Function</a></h3>
<p>From <code>crates/groth16/src/verify.rs:66-167</code>:</p>
<pre><code class="language-rust ignore">/// Verifies a Groth16 zero-knowledge proof.
pub fn verify_proof(
    vk: &amp;VerificationKey,
    proof: &amp;Proof,
    public_inputs: &amp;[FieldWrapper&lt;Fq&gt;],
) -&gt; Result&lt;bool, Groth16Error&gt; {
    // Helper function to convert FieldWrapper&lt;Fq&gt; to Fr
    fn fq_to_fr(fq: &amp;Fq) -&gt; &lt;Bn254 as Pairing&gt;::ScalarField {
        let bytes = fq.into_bigint().to_bytes_be();
        let mut padded = [0u8; 32];
        let start = 32usize.saturating_sub(bytes.len());
        padded[start..].copy_from_slice(&amp;bytes);
        &lt;Bn254 as Pairing&gt;::ScalarField::from_be_bytes_mod_order(&amp;padded)
    }

    // Step 1: Compute left side of verification equation
    // Left side: e(A, B)
    let left = Bn254::pairing(proof.a, proof.b);

    // Step 2: Compute right side components
    // Component 1: e(Œ±, Œ≤)
    let alpha_beta = Bn254::pairing(vk.alpha_g1, vk.beta_g2);

    // Component 2: e(Œ£public_i¬∑IC_i, Œ≥)
    // Check if IC includes the constant (IC length = public_inputs + 1)
    let has_constant = vk.ic.len() == public_inputs.len() + 1;

    let mut public_acc = G1::zero();

    if has_constant {
        // IC[0] is for constant 1, IC[1..] are for public inputs
        if !vk.ic.is_empty() {
            public_acc += G1::from(vk.ic[0]);
        }
        for (i, input) in public_inputs.iter().enumerate() {
            if i + 1 &lt; vk.ic.len() {
                let input_scalar = fq_to_fr(&amp;input.value);
                let ic_point = G1::from(vk.ic[i + 1]);
                public_acc += ic_point * input_scalar;
            }
        }
    }

    let public_gamma = Bn254::pairing(public_acc, vk.gamma_g2);

    // Component 3: e(C, Œ¥)
    let c_delta = Bn254::pairing(proof.c, vk.delta_g2);

    // Right side: e(Œ±, Œ≤) ¬∑ e(Œ£public¬∑IC, Œ≥) ¬∑ e(C, Œ¥)
    let right_field = alpha_beta.0 * public_gamma.0 * c_delta.0;

    // Step 3: Check if verification equation holds
    let is_valid = left.0 == right_field;

    Ok(is_valid)
}</code></pre>
<h3 id="the-verification-algorithm"><a class="header" href="#the-verification-algorithm">The Verification Algorithm</a></h3>
<ol>
<li><strong>Compute left side</strong>: <code>e(A, B)</code> using the pairing</li>
<li><strong>Compute right side</strong>:
<ul>
<li><code>e(Œ±, Œ≤)</code> from the verification key</li>
<li><code>e(Œ£public¬∑IC, Œ≥)</code> by combining public inputs with IC elements</li>
<li><code>e(C, Œ¥)</code> from the proof and verification key</li>
</ul>
</li>
<li><strong>Multiply the right side components</strong>: <code>e(Œ±, Œ≤) ¬∑ e(Œ£public¬∑IC, Œ≥) ¬∑ e(C, Œ¥)</code></li>
<li><strong>Compare</strong>: Check if left equals right</li>
</ol>
<h2 id="running-the-code-5"><a class="header" href="#running-the-code-5">Running the Code</a></h2>
<h3 id="example-verifying-a-proof"><a class="header" href="#example-verifying-a-proof">Example: Verifying a Proof</a></h3>
<pre><code class="language-rust ignore">use groth16_groth16::{trusted_setup, generate_proof, verify_proof};
use groth16_circuits::multiplier::MultiplierCircuit;
use groth16_qap::r1cs_to_qap;

// Setup and proof generation
let circuit = MultiplierCircuit::new(3, 4, 12);
let witness = circuit.witness();
let constraints = circuit.to_r1cs();
let (a_polys, b_polys, c_polys) = r1cs_to_qap(&amp;constraints, 4)?;
let (pk, vk) = trusted_setup(&amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng)?;
let proof = generate_proof(&amp;pk, &amp;witness, &amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng)?;

// Verify with public input c=12
let public_inputs = vec![FieldWrapper::&lt;Fq&gt;::from(12u64)];
let is_valid = verify_proof(&amp;vk, &amp;proof, &amp;public_inputs)?;

assert!(is_valid);  // Proof should be valid
println!("Proof verification: {}", is_valid);</code></pre>
<h3 id="example-invalid-proof"><a class="header" href="#example-invalid-proof">Example: Invalid Proof</a></h3>
<pre><code class="language-rust ignore">// Try to verify with wrong public input
let wrong_public_inputs = vec![FieldWrapper::&lt;Fq&gt;::from(13u64)];  // Should be 12
let is_valid = verify_proof(&amp;vk, &amp;proof, &amp;wrong_public_inputs)?;

assert!(!is_valid);  // Proof should be invalid</code></pre>
<h2 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h2>
<h3 id="constant-time-verification"><a class="header" href="#constant-time-verification">Constant-Time Verification</a></h3>
<p>Verification is <strong>O(1)</strong> regardless of circuit size:</p>
<ul>
<li>3 pairing operations (constant time)</li>
<li>O(n) field multiplications for public inputs (usually small n)</li>
<li>No computation over constraints!</li>
</ul>
<p>For a circuit with 1 million constraints:</p>
<ul>
<li>Proving time: O(n) ~ several seconds</li>
<li>Verification time: O(1) ~ a few milliseconds</li>
</ul>
<h3 id="batch-verification"><a class="header" href="#batch-verification">Batch Verification</a></h3>
<p>We can verify multiple proofs efficiently using random linear combination:</p>
<p>From <code>crates/groth16/src/verify.rs:169-240</code>:</p>
<pre><code class="language-rust ignore">/// Batch verifies multiple Groth16 proofs efficiently using random linear combination.
///
/// Instead of O(n) pairing operations for n proofs, we use O(1) pairings total.
pub fn batch_verify&lt;R: Rng&gt;(
    vk: &amp;VerificationKey,
    proofs: &amp;[Proof],
    public_inputs_list: &amp;[Vec&lt;FieldWrapper&lt;Fq&gt;&gt;],
    rng: &amp;mut R,
) -&gt; Result&lt;bool, Groth16Error&gt;
{
    // Generate random coefficients for each proof
    let mut coeffs = Vec::with_capacity(proofs.len());
    for _ in 0..proofs.len() {
        let r = Fr::rand(rng);
        coeffs.push(r);
    }

    // Compute combined left side: e(Œ£ r·µ¢¬∑A·µ¢, B·µ¢)
    let mut combined_a = G1::zero();
    for (i, proof) in proofs.iter().enumerate() {
        combined_a += G1::from(proof.a) * coeffs[i];
    }
    let left = Bn254::pairing(combined_a, proofs[0].b);

    // Compute combined right side
    // ... (similar combination for right side)

    // Single pairing check for all proofs
    Ok(left.0 == right.0)
}</code></pre>
<p><strong>Speedup</strong>: For n proofs:</p>
<ul>
<li>Individual: ~3n pairings</li>
<li>Batch: ~3 pairings (constant!)</li>
<li>Speedup: Approximately n√ó faster</li>
</ul>
<h2 id="security-properties-2"><a class="header" href="#security-properties-2">Security Properties</a></h2>
<h3 id="soundness-1"><a class="header" href="#soundness-1">Soundness</a></h3>
<p>A false proof will be rejected with overwhelming probability:</p>
<ul>
<li>The pairing equation would fail</li>
<li>Cannot forge without knowing toxic waste</li>
<li>Cryptographic assumptions: ECDLP, SDH</li>
</ul>
<h3 id="zero-knowledge-1"><a class="header" href="#zero-knowledge-1">Zero-Knowledge</a></h3>
<p>Verification reveals nothing about the witness:</p>
<ul>
<li>Only public inputs and the proof are visible</li>
<li>Pairings don't leak information about discrete logs</li>
<li>Blinding factors (r, s) ensure proof diversity</li>
</ul>
<h3 id="succinctness"><a class="header" href="#succinctness">Succinctness</a></h3>
<p>Verification is incredibly efficient:</p>
<ul>
<li>Constant-time regardless of circuit complexity</li>
<li>Small proof size (128 bytes)</li>
<li>Fast verification (~milliseconds)</li>
</ul>
<h2 id="connection-to-groth16-5"><a class="header" href="#connection-to-groth16-5">Connection to Groth16</a></h2>
<p>Verification is the <strong>final step</strong> of Groth16:</p>
<pre><code class="language-text">Computation
    ‚Üì
R1CS (matrix constraints)
    ‚Üì
QAP (polynomial divisibility)
    ‚Üì
Elliptic Curve Pairings
    ‚Üì
Trusted Setup
    ‚Üì
Proof Generation
    ‚Üì
Proof Verification ‚Üê You are here
</code></pre>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<ol>
<li>
<p><strong>Verification equation</strong>:</p>
<pre><code class="language-text">Why do we need e(Œ±, Œ≤) on the right side?
What would happen if we removed it?
</code></pre>
</li>
<li>
<p><strong>Public input consistency</strong>:</p>
<pre><code class="language-text">How does the IC vector ensure public inputs are correct?
What happens if the prover lies about public inputs?
</code></pre>
</li>
<li>
<p><strong>Batch verification</strong>:</p>
<pre><code class="language-text">Why does batch verification work?
What's the security requirement for the random coefficients?
</code></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">Can we verify a proof without the verification key?
What parts of the VK are essential?
</code></pre>
</li>
</ol>
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further Reading</a></h2>
<ul>
<li><strong>Pairing Verification</strong>: <a href="https://www.cryptologie.net/article/328/pairing-based-cryptography/">Pairing-Based Cryptography</a></li>
<li><strong>Batch Verification</strong>: <a href="https://eprint.iacr.org/2020/1628">Batch Verification Techniques</a></li>
<li><strong>Groth16 Security</strong>: <a href="https://eprint.iacr.org/2016/260">Groth16 Security Proof</a></li>
</ul>
<hr />
<p><strong>Ready to build circuits? Continue to <a href="./08-building-circuits.html">Chapter 8: Building Your Own Circuits</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-own-circuits"><a class="header" href="#building-your-own-circuits">Building Your Own Circuits</a></h1>
<p>Congratulations! You've made it through the theory. Now let's put it all together and learn how to build your own zero-knowledge circuits!</p>
<h2 id="learning-objectives-8"><a class="header" href="#learning-objectives-8">Learning Objectives</a></h2>
<p>After this chapter, you will understand:</p>
<ul>
<li>How to design a circuit from a computation</li>
<li>Best practices for circuit construction</li>
<li>Common circuit patterns and idioms</li>
<li>How to test and debug circuits</li>
<li>Performance considerations</li>
</ul>
<h2 id="motivating-example-from-idea-to-circuit"><a class="header" href="#motivating-example-from-idea-to-circuit">Motivating Example: From Idea to Circuit</a></h2>
<p>Let's say you want to prove you know a secret password hash without revealing the password.</p>
<p><strong>Computation</strong>: Hash(password) = claimed_hash</p>
<p><strong>Circuit design</strong>:</p>
<ol>
<li>Identify inputs: password (private), claimed_hash (public)</li>
<li>Define the computation: Hash function</li>
<li>Encode as R1CS constraints</li>
<li>Generate witness, proof, and verify!</li>
</ol>
<h2 id="circuit-design-process"><a class="header" href="#circuit-design-process">Circuit Design Process</a></h2>
<h3 id="step-1-identify-inputs-and-outputs"><a class="header" href="#step-1-identify-inputs-and-outputs">Step 1: Identify Inputs and Outputs</a></h3>
<p>First, clearly define what's private and what's public:</p>
<p><strong>Example</strong>: Age verification</p>
<ul>
<li><strong>Private</strong>: Your age</li>
<li><strong>Public</strong>: Threshold (e.g., 18)</li>
<li><strong>Output</strong>: Are you over 18? (yes/no)</li>
</ul>
<h3 id="step-2-break-down-the-computation"><a class="header" href="#step-2-break-down-the-computation">Step 2: Break Down the Computation</a></h3>
<p>Complex computations need to be broken into simple operations:</p>
<p><strong>Supported operations</strong>:</p>
<ul>
<li>Addition: <code>a + b = c</code></li>
<li>Multiplication: <code>a √ó b = c</code></li>
<li>Subtraction: <code>a - b = c</code> (addition with negative)</li>
<li>Division: <code>a / b = c</code> (multiplication with inverse)</li>
</ul>
<p><strong>Not directly supported</strong>:</p>
<ul>
<li>Bitwise operations (need to decompose into bits)</li>
<li>Comparison (need to decompose into bits)</li>
<li>Range checks (need specialized circuits)</li>
</ul>
<h3 id="step-3-add-intermediate-variables"><a class="header" href="#step-3-add-intermediate-variables">Step 3: Add Intermediate Variables</a></h3>
<p>For complex computations, introduce intermediate variables:</p>
<p><strong>Example</strong>: <code>(a + b) √ó (a - b) = c</code></p>
<p>Variables: <code>z = [1, c, a, b, t‚ÇÅ, t‚ÇÇ]</code></p>
<p>Constraints:</p>
<pre><code class="language-text">t‚ÇÅ = a + b
t‚ÇÇ = a - b
c = t‚ÇÅ √ó t‚ÇÇ
</code></pre>
<h3 id="step-4-encode-as-r1cs"><a class="header" href="#step-4-encode-as-r1cs">Step 4: Encode as R1CS</a></h3>
<p>Convert each operation into an R1CS constraint:</p>
<p><strong>Addition constraint</strong>: <code>t‚ÇÅ = a + b</code></p>
<pre><code class="language-text">A = [0, 0, 1, 1, 0, 0]  ‚Üê a + b
B = [1, 0, 0, 0, 0, 0]  ‚Üê 1
C = [0, 0, 0, 0, 1, 0]  ‚Üê t‚ÇÅ
</code></pre>
<p><strong>Multiplication constraint</strong>: <code>c = t‚ÇÅ √ó t‚ÇÇ</code></p>
<pre><code class="language-text">A = [0, 0, 0, 0, 1, 0]  ‚Üê t‚ÇÅ
B = [0, 0, 0, 0, 0, 1]  ‚Üê t‚ÇÇ
C = [0, 1, 0, 0, 0, 0]  ‚Üê c
</code></pre>
<h2 id="circuit-patterns"><a class="header" href="#circuit-patterns">Circuit Patterns</a></h2>
<h3 id="pattern-1-boolean-circuits"><a class="header" href="#pattern-1-boolean-circuits">Pattern 1: Boolean Circuits</a></h3>
<p>For operations on bits (0 or 1):</p>
<p><strong>Bit constraint</strong>: <code>b ‚àà {0, 1}</code></p>
<pre><code class="language-text">b √ó (1 - b) = 0
</code></pre>
<p>R1CS:</p>
<pre><code class="language-text">A = [0, 0, 1, 0]  ‚Üê b
B = [1, 0, -1, 0] ‚Üê 1 - b
C = [0, 1, 0, 0]  ‚Üê 0
</code></pre>
<p><strong>Bitwise AND</strong>: <code>c = a AND b</code></p>
<pre><code class="language-text">c = a √ó b
</code></pre>
<p><strong>Bitwise OR</strong>: <code>c = a OR b</code></p>
<pre><code class="language-text">c = a + b - (a √ó b)
</code></pre>
<p><strong>Bitwise XOR</strong>: <code>c = a XOR b</code></p>
<pre><code class="language-text">c = a + b - 2(a √ó b)
</code></pre>
<h3 id="pattern-2-comparison-circuits"><a class="header" href="#pattern-2-comparison-circuits">Pattern 2: Comparison Circuits</a></h3>
<p>To check if <code>a &gt; b</code>:</p>
<ol>
<li>Compute <code>d = a - b</code></li>
<li>Decompose <code>d</code> into bits</li>
<li>Use the most significant bit (sign bit) to determine comparison</li>
</ol>
<h3 id="pattern-3-range-check-circuits"><a class="header" href="#pattern-3-range-check-circuits">Pattern 3: Range Check Circuits</a></h3>
<p>To check if <code>x</code> is in range <code>[0, 2‚Åø)</code>:</p>
<ol>
<li>Decompose <code>x</code> into <code>n</code> bits</li>
<li>Each bit must satisfy the bit constraint</li>
<li>This ensures <code>0 ‚â§ x &lt; 2‚Åø</code></li>
</ol>
<h3 id="pattern-4-equality-check"><a class="header" href="#pattern-4-equality-check">Pattern 4: Equality Check</a></h3>
<p>To check if <code>a = b</code>:</p>
<ol>
<li>Compute <code>d = a - b</code></li>
<li>Check if <code>d = 0</code> using <code>d √ó d = 0</code> (or more sophisticated methods)</li>
</ol>
<h2 id="implementation-building-a-circuit"><a class="header" href="#implementation-building-a-circuit">Implementation: Building a Circuit</a></h2>
<p>Let's implement a simple circuit from scratch.</p>
<h3 id="example-cubic-circuit"><a class="header" href="#example-cubic-circuit">Example: Cubic Circuit</a></h3>
<p>Circuit: <code>y = x¬≥</code></p>
<pre><code class="language-rust ignore">use ark_bn254::Fq;
use groth16_math::fields::FieldWrapper;
use groth16_r1cs::constraint::R1CSConstraint;

pub struct CubicCircuit {
    pub x: u64,
    pub y: u64,
}

impl CubicCircuit {
    pub fn new(x: u64, y: u64) -&gt; Self {
        Self { x, y }
    }

    pub fn to_r1cs(&amp;self) -&gt; Vec&lt;R1CSConstraint&lt;Fq&gt;&gt; {
        let mut constraints = Vec::new();

        // Constraint 1: t = x √ó x (square)
        let mut c1 = R1CSConstraint::&lt;Fq&gt;::new();
        c1.add_a_variable(1, FieldWrapper::&lt;Fq&gt;::from(1u64));  // x
        c1.add_b_variable(1, FieldWrapper::&lt;Fq&gt;::from(1u64));  // x
        c1.add_c_variable(2, FieldWrapper::&lt;Fq&gt;::from(1u64));  // t
        constraints.push(c1);

        // Constraint 2: y = t √ó x (cube)
        let mut c2 = R1CSConstraint::&lt;Fq&gt;::new();
        c2.add_a_variable(2, FieldWrapper::&lt;Fq&gt;::from(1u64));  // t
        c2.add_b_variable(1, FieldWrapper::&lt;Fq&gt;::from(1u64));  // x
        c2.add_c_variable(3, FieldWrapper::&lt;Fq&gt;::from(1u64));  // y
        constraints.push(c2);

        constraints
    }

    pub fn witness(&amp;self) -&gt; Vec&lt;FieldWrapper&lt;Fq&gt;&gt; {
        vec![
            FieldWrapper::&lt;Fq&gt;::from(1u64),   // constant 1
            FieldWrapper::&lt;Fq&gt;::from(self.x),  // x
            FieldWrapper::&lt;Fq&gt;::from(self.x * self.x),  // t = x¬≤
            FieldWrapper::&lt;Fq&gt;::from(self.y),  // y
        ]
    }
}</code></pre>
<h3 id="example-multiplier-circuit-recap"><a class="header" href="#example-multiplier-circuit-recap">Example: Multiplier Circuit (Recap)</a></h3>
<p>From <code>crates/circuits/src/multiplier.rs:45-131</code>:</p>
<pre><code class="language-rust ignore">pub struct MultiplierCircuit {
    pub a: u64,
    pub b: u64,
    pub c: u64,
}

impl MultiplierCircuit {
    pub fn new(a: u64, b: u64, c: u64) -&gt; Self {
        Self { a, b, c }
    }

    pub fn to_r1cs(&amp;self) -&gt; Vec&lt;R1CSConstraint&lt;Fq&gt;&gt; {
        let mut constraint = R1CSConstraint::&lt;Fq&gt;::new();

        // A vector: selects variable a (index 2)
        constraint.add_a_variable(2, FieldWrapper::&lt;Fq&gt;::from(1u64));

        // B vector: selects variable b (index 3)
        constraint.add_b_variable(3, FieldWrapper::&lt;Fq&gt;::from(1u64));

        // C vector: selects variable c (index 1)
        constraint.add_c_variable(1, FieldWrapper::&lt;Fq&gt;::from(1u64));

        vec![constraint]
    }

    pub fn witness(&amp;self) -&gt; Vec&lt;FieldWrapper&lt;Fq&gt;&gt; {
        vec![
            FieldWrapper::&lt;Fq&gt;::from(1u64),   // constant 1
            FieldWrapper::&lt;Fq&gt;::from(self.c), // public output c
            FieldWrapper::&lt;Fq&gt;::from(self.a), // private input a
            FieldWrapper::&lt;Fq&gt;::from(self.b), // private input b
        ]
    }
}</code></pre>
<h2 id="testing-your-circuit"><a class="header" href="#testing-your-circuit">Testing Your Circuit</a></h2>
<p>Always test your circuit thoroughly!</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_circuit_valid() {
        let circuit = CubicCircuit::new(3, 27);  // 3¬≥ = 27
        let constraints = circuit.to_r1cs();
        let witness = circuit.witness();

        // Verify each constraint
        for constraint in &amp;constraints {
            assert!(constraint.is_satisfied(&amp;witness));
        }
    }

    #[test]
    fn test_circuit_invalid() {
        let circuit = CubicCircuit::new(3, 26);  // 3¬≥ ‚â† 26
        let constraints = circuit.to_r1cs();
        let witness = circuit.witness();

        // Should fail at least one constraint
        let all_satisfied = constraints.iter()
            .all(|c| c.is_satisfied(&amp;witness));
        assert!(!all_satisfied);
    }
}</code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<pre><code class="language-rust ignore">#[test]
fn test_full_groth16_flow() {
    use groth16_groth16::{trusted_setup, generate_proof, verify_proof};
    use groth16_qap::r1cs_to_qap;

    // Create circuit
    let circuit = CubicCircuit::new(3, 27);
    let witness = circuit.witness();
    let constraints = circuit.to_r1cs();

    // Convert to QAP
    let (a_polys, b_polys, c_polys) = r1cs_to_qap(&amp;constraints, witness.len()).unwrap();

    // Trusted setup
    let (pk, vk) = trusted_setup(&amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng).unwrap();

    // Generate proof
    let proof = generate_proof(&amp;pk, &amp;witness, &amp;a_polys, &amp;b_polys, &amp;c_polys, 1, &amp;mut rng).unwrap();

    // Verify with public input y=27
    let public_inputs = vec![FieldWrapper::&lt;Fq&gt;::from(27u64)];
    let is_valid = verify_proof(&amp;vk, &amp;proof, &amp;public_inputs).unwrap();

    assert!(is_valid);
}</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-minimize-constraints"><a class="header" href="#1-minimize-constraints">1. Minimize Constraints</a></h3>
<p>Fewer constraints = faster proving and smaller keys.</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-text">a + a + a + a + a = b  (5 additions)
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-text">t = a √ó 5  (1 multiplication)
t = b
</code></pre>
<h3 id="2-reuse-intermediate-values"><a class="header" href="#2-reuse-intermediate-values">2. Reuse Intermediate Values</a></h3>
<p>Compute once, use multiple times.</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-text">t‚ÇÅ = x √ó x
t‚ÇÇ = x √ó x
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-text">t = x √ó x
</code></pre>
<h3 id="3-use-field-arithmetic"><a class="header" href="#3-use-field-arithmetic">3. Use Field Arithmetic</a></h3>
<p>Take advantage of field properties:</p>
<ul>
<li>Modular arithmetic is automatic</li>
<li>No overflow concerns</li>
<li>Use field inverses for division</li>
</ul>
<h3 id="4-document-your-circuits"><a class="header" href="#4-document-your-circuits">4. Document Your Circuits</a></h3>
<p>Other developers need to understand your circuit:</p>
<pre><code class="language-rust ignore">/// Range proof circuit: proves that x is in range [0, 2‚Åø)
///
/// Private inputs:
/// - x: the value to prove is in range
///
/// Public inputs:
/// - n: the bit length
///
/// Constraints:
/// - Decompose x into n bits
/// - Each bit must satisfy b √ó (1 - b) = 0</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="proving-time"><a class="header" href="#proving-time">Proving Time</a></h3>
<p>Proving time is <strong>O(n)</strong> where n is the number of constraints:</p>
<ul>
<li>Small circuits (&lt; 1000 constraints): &lt; 1 second</li>
<li>Medium circuits (1000-100000): 1-10 seconds</li>
<li>Large circuits (&gt; 100000): 10+ seconds</li>
</ul>
<p><strong>Optimization</strong>: Use parallelization for large circuits.</p>
<h3 id="proof-size-1"><a class="header" href="#proof-size-1">Proof Size</a></h3>
<p>Proof size is <strong>constant</strong>: 128 bytes</p>
<ul>
<li>Doesn't grow with circuit complexity</li>
<li>Efficient for transmission and storage</li>
</ul>
<h3 id="verification-time"><a class="header" href="#verification-time">Verification Time</a></h3>
<p>Verification time is <strong>O(1)</strong>: constant regardless of circuit size</p>
<ul>
<li>Usually &lt; 10 milliseconds</li>
<li>Efficient for on-chain verification</li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-incorrect-witness-order"><a class="header" href="#1-incorrect-witness-order">1. Incorrect Witness Order</a></h3>
<p>The witness order matters: <code>[1, public..., private...]</code></p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-rust ignore">vec![
    FieldWrapper::&lt;Fq&gt;::from(self.a),  // Wrong order!
    FieldWrapper::&lt;Fq&gt;::from(self.b),
    FieldWrapper::&lt;Fq&gt;::from(self.c),
]</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-rust ignore">vec![
    FieldWrapper::&lt;Fq&gt;::from(1u64),   // Constant first
    FieldWrapper::&lt;Fq&gt;::from(self.c), // Public output
    FieldWrapper::&lt;Fq&gt;::from(self.a), // Private inputs
    FieldWrapper::&lt;Fq&gt;::from(self.b),
]</code></pre>
<h3 id="2-forgetting-intermediate-variables"><a class="header" href="#2-forgetting-intermediate-variables">2. Forgetting Intermediate Variables</a></h3>
<p>Complex computations need intermediate variables:</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-text">y = (a + b) √ó (c + d)  // Can't encode directly!
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-text">t‚ÇÅ = a + b
t‚ÇÇ = c + d
y = t‚ÇÅ √ó t‚ÇÇ
</code></pre>
<h3 id="3-not-testing-edge-cases"><a class="header" href="#3-not-testing-edge-cases">3. Not Testing Edge Cases</a></h3>
<p>Test with:</p>
<ul>
<li>Zero values</li>
<li>Maximum values</li>
<li>Boundary conditions</li>
<li>Invalid inputs</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you know how to build circuits:</p>
<ol>
<li><strong>Practice</strong>: Implement your own circuits</li>
<li><strong>Optimize</strong>: Learn circuit optimization techniques</li>
<li><strong>Explore</strong>: Study advanced circuit patterns</li>
<li><strong>Build</strong>: Create real-world applications!</li>
</ol>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ol>
<li>
<p><strong>Square circuit</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Implement a circuit that computes y = x¬≤
Test it with various inputs
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Comparison circuit</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Implement a circuit that checks if a &gt; b
Hint: Decompose into bits and compare
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Range proof</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Implement a circuit that proves x is in [0, 256)
Hint: Use 8 bits and bit constraints
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Challenge question</strong>:</p>
<pre><code class="language-text">How would you implement a hash function circuit?
What operations do you need?
</code></pre>
</li>
</ol>
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further Reading</a></h2>
<ul>
<li><strong>Circuit Optimization</strong>: <a href="https://github.com/zkcrypto/bellman">Bellman Documentation</a></li>
<li><strong>Circuit Patterns</strong>: <a href="https://media.githubusercontent.com/media/zcash/zcash/master/doc/protocol/sapling.pdf">ZK-SNARKs Circuit Design</a></li>
<li><strong>Advanced Circuits</strong>: <a href="https://zips.z.cash/protocol/protocol.pdf#orchard">Zcash Orchard Specification</a></li>
</ul>
<hr />
<p><strong>Congratulations! You've completed the Groth16 tutorial!</strong></p>
<p>Now you're ready to:</p>
<ul>
<li>Build your own zero-knowledge proofs</li>
<li>Contribute to zk-SNARK projects</li>
<li>Explore advanced protocols (PLONK, Halo 2, etc.)</li>
</ul>
<p><strong>Happy proving!</strong> üéâ</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
